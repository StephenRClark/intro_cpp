[
  {
    "objectID": "exercises_consolidation.html",
    "href": "exercises_consolidation.html",
    "title": "Consolidation exercises",
    "section": "",
    "text": "Here are some simple consolidation exercises you can try covering all the material workshops 1-4.\n\n\n\n\n\n\nStarter code\n\n\n\nDownload on to your computer the .zip exercise file.\n\n\n\n\n\n\n\n\nTask 1: Highest and lowest marks\n\n\n\nDownload the starter code marks_q1.cpp. This code contains an array of exam marks for some 4th year Physics course. Compile and run the code. The marks should be displayed on the screen. Now modify marks_q1.cpp so it finds and prints the highest and lowest mark for the course.\n\n\n\n\n\n\n\n\nTask 2: Statistics of marks\n\n\n\nCopy marks_q1.cpp to a new file marks_q2.cpp. Now add new functionality by also computing the average mark \\[\n\\langle M \\rangle = \\frac 1n \\sum_i M_i,\n\\] and the standard deviation \\(\\sigma\\) which is the square-root of the variance \\[\n\\sigma^2 = \\frac 1n \\sum_i (M_i - \\langle M \\rangle)^2,\n\\] where \\(M_i\\) is the \\(i\\)th mark of the set of \\(n\\) marks. Display both results to one decimal place.\n\n\n\n\n\n\n\n\nTask 3: Tidy implementation\n\n\n\nDownload the starter code marks_q3.cpp. This is identical to marks_q1.cpp except that it also includes declarations for a function min_max() that computes the min/max marks and avg_std() which computes the average/standard deviation of the marks. Use your answers to questions 1 and 2 to help write the implementations of these functions in marks_q3.cpp. Compile and run the code to check it produces identical results to earlier.\n\n\n\n\n\n\n\n\nTask 4: Swap function\n\n\n\nDownload the starter code swap_q4.cpp. This code defines a \\(3 \\times 3\\) matrix in an array and computes its transposition. Complete the code by writing the implementation of the swap elements function swapf() declared. Compile and run the code to confirm it works.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThe solutions to the above problems are available in the .zip solutions file.",
    "crumbs": [
      "=> Consolidation exercises"
    ]
  },
  {
    "objectID": "arrays_vectors.html",
    "href": "arrays_vectors.html",
    "title": "Arrays and Vectors",
    "section": "",
    "text": "This background information document will provide you with a concise introduction to using arrays in C/C++ and the vector class in C++.",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "arrays_vectors.html#arrays",
    "href": "arrays_vectors.html#arrays",
    "title": "Arrays and Vectors",
    "section": "Arrays",
    "text": "Arrays\nIn programming, we often encounter not just single variables but collections of related variables which need to handle efficiently. For example this could include positions of atoms in molecule, daily measurements of atmospheric pressure, components of a vector and so on. Almost all programming language deal with this using the concept of arrays. Members of an array are known as elements and each element is identified by a number, called the index. Each element is like a separate variable. An array in C/C++ is defined almost identically to a standard variable as &lt;type&gt; &lt;var_name&gt;[&lt;size&gt;] but now includes a size:\nint A[3]; // Define an array of 3 integers\nFrom this we notice a couple of important features (or limitations) of C/C++ arrays:\n\nThere are of fixed size defined by an integer value at compile-time in our source code. So &lt;size&gt; cannot itself be an integer variable1.\nThey can only contain variables of the same type specified by &lt;type&gt;.\n\nOnce defined elements of the arrays are accessed &lt;var_name&gt;[&lt;index&gt;] and each behave identically to a single variable of the same type. Indexing starts from zero so elements of the array A are A[0], A[1] and A[2]. We can change the value of elements through assignments just like a variable of the same type, hence:\n// Set the values in A\nA[0] = 1;\nA[1] = 17;\nA[2] = 9;\nWe can also initialise arrays with values within our declaration:\nint A[3] = {1, 17, 9}; // Define and initialise array of 3 integers\nint B[]  = {8, 23, 256, 76, 10}; // Define and initialise array with size implied\nIn the second line we define B as an array but with an empty size leaving to the compiler to insert the size (in this case 5) as implied by our initialisation. If we repeatedly use arrays of a certain fixed size we can avoid having to explicitly write this size for every declaration in at least two ways. First, we could define a pre-processor symbol which gets replaced by a value before compilation. Second, we could define a static const variable which the compiler treats as a constant. Consider this example:\n#include &lt;iostream&gt; \n\nint main()\n{\n    static const int num = 22; // The number of integers\n    static const int dim = 3; // The dimensions of vectors\n\n    int A[num]; // Define an array of num integers\n    float u[dim] = {1.0, 2.0, 3.0}; // Initialised so don't technically need to use dim\n    float v[dim] = {2.0, 4.0, 3.0};\n    float result = 0.0;\n \n    // Display values of the arrays\n    for(int i=0; i&lt;num; i++) std::cout &lt;&lt; A[i] &lt;&lt; std::endl;\n    for(int i=0; i&lt;dim; i++) std::cout &lt;&lt; u[i] &lt;&lt; \" \" &lt;&lt; v[i] &lt;&lt; std::endl;\n\n    for (int i=0; i&lt;dim; i++) result = result + u[i]*v[i]; \n    std::cout &lt;&lt; \"Scalar product is \" &lt;&lt; result &lt;&lt; std::endl;\n\n    return EXIT_SUCCESS; \n}\nShould we want to change the number of components dim in our vectors, having a single definition for dim avoids lots of retyping and inevitable typos. This example highlights another important point. If not explicitly initialised then arrays will be filled with garbage values left over in whatever memory was allocated to it. As such the above program will list junk for A. Do not assume arrays will be filled with zeros automatically.\nContrast these features with Python. It has arrays just like above, but also has an extremely general and powerful concept of a list which acts as a container for variables of any type that can be dynamically resized. For example:\nx = [3, 'a', 3.2, 'bananas', [3, 2]]  # A Python list declaration!\nBeing a light-weight mid-level programming language C/C++ does not provide this kind of flexibility via its basic syntax, although we will see in the last workshop that structures give us some similar abilities.",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "arrays_vectors.html#multi-dimensional-arrays",
    "href": "arrays_vectors.html#multi-dimensional-arrays",
    "title": "Arrays and Vectors",
    "section": "Multi-dimensional arrays",
    "text": "Multi-dimensional arrays\nFrequently we may want to label the elements of our array with more than one index or dimensions. The obvious use for this is to store matrices in the case of 2 dimensional arrays, or more generally tensors for higher dimensions. In C/C++ this can be done by simply specifying additional sizes in the declaration as:\nint A[3][3]; // Define a 2D array of 3 x 3 integers\nWe can also declare and initialise together as:\nfloat M[2][2] = {{2.1, 1.9}, {-3.0, 4.5}};\nwhere we specify the rows within nested {.} brackets (so-called row-major ordering). The elements of the 2D array are accessed using pairs of indices enclosed by [.], so the resulting matrix is: \\[\n\\left( \\begin{array}{cc}\n  {\\tt M[0][0] } & {\\tt M[0][1] } \\\\\n  {\\tt M[1][0] } & {\\tt M[1][1] }\n\\end{array} \\right)\n=\n\\left( \\begin{array}{rr}\n  2.1 & 1.9 \\\\\n  -3.0 & 4.5\n\\end{array} \\right).\n\\] Naturally, we can easily write some code to implement matrix multiplication. The pseudocode for the matrix product \\(C_{ij}\\) of two \\(n\\times n\\) matrices, \\(A_{ij}\\) and \\(B_{ij}\\) is as follows:\nloop i from 0 to n-1\n\n    loop j from 0 to n-1\n\n        set C[i,j] to 0.0\n\n        loop k from 0 to n-1\n\n            increment C[i,j] by A[i,k] x B[k,j]\n\n        end loop over k\n\n    end loop over j\n\nend loop over i\nThe implements the “row-on-column\" matrix multiplication rule, so for example: \\[\n\\left( \\begin{array}{cc}\n2 & 0 \\\\\n3 & 1 \\end{array} \\right)\n\\times\n\\left( \\begin{array}{cc}\n1 & 1 \\\\\n-2 & 0 \\end{array} \\right)\n=\n\\left( \\begin{array}{cc}\n2\\times 1+0\\times (-2) & 2 \\times 1+0\\times 0 \\\\\n3\\times 1+ 1\\times(-2) & 3\\times 1 + 1\\times 0 \\end{array} \\right) = \\left( \\begin{array}{cc}\n2 & 2 \\\\\n1 & 3 \\end{array} \\right).\n\\] Here is some C/C++ code implementing this:\n#include &lt;iostream&gt;\n\nint main() \n{\n  static const int n = 2; // Define square matrix size\n  float A[n][n] = {{2,0},{3,1}}; // Declare and initialise\n  float B[n][n] = {{1,1},{-2,0}}; \n  float C[n][n];\n\n  for(int i=0; i&lt;n; i++) \n  {\n    for(int j=0; j&lt;n; j++) \n    {\n      C[i][j] = 0.0; // Initialise C to erase junk\n      for(int k=0; k&lt;n; k++) \n      {\n        C[i][j] += A[i][k]*B[k][j];\n      }\n      std::cout &lt;&lt; C[i][j] &lt;&lt; \" \"; // Display result\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n  \n  return EXIT_SUCCESS;\n}\nHigher dimensional arrays can be defined by specifying even more sizes:\nint A[3][3][10]; // Define a 3D array of 3 x 3 x 10 integers\nand elements are accessed similarly using more indices, in this case three as A[i][j][k].",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "arrays_vectors.html#vectors",
    "href": "arrays_vectors.html#vectors",
    "title": "Arrays and Vectors",
    "section": "Vectors",
    "text": "Vectors\nThere are several problems with basic arrays in C/C++. The main one is technical, in that arrays have a fixed size defined at compile-time in your source code. This can often be a severe limitation since there are many situations where you do not know in advance how large your arrays will be, or want to allow you code to be able handle any size requested by the user at run-time. An old-fashioned C-style solution to this problem is to use pointers and dynamic memory allocation, which is discussed for completeness in the optional background document Pointers. A second problem is more conceptual, in that the nature of arrays are very much based on a C programming paradigm. As such an array’s length/size is not part of its data type. In most situations, as far as the compiler is concerned, int a[10] and int b[20] are of the same type, and you can’t retrieve from the array itself whether it has 10 or 20 entries. This violates the stronger notion of a data type used in C++ and can be a source of bugs and exploits in code. Since this course is aiming at a modern introduction to C++ we will discuss here the use of the vector class from the C++ standard library which solves both these issues.\nTo use vectors we need to include an additional header #include &lt;vector&gt; in our source file. We can then declare a vector class using the general form:\nstd::vector&lt;type&gt; vector_name;\nwhere &lt;type&gt; can be any primitive data type int, float, char, double, or more generally user-defined one such as an object class (see last workshop). Do not concern yourself too much with the slightly weird std::vector&lt;type&gt; notation needed above. This relates to something called templating which we will not cover in this course but which you will discuss in more detail in later years. For now just use this notation as is without thinking too hard about its deeper meaning. So for example\nstd::vector&lt;double&gt; data;\ndefines a vector of doubles called data. We have not specified a size of the vector here. We shall see shortly that we can grow it dynamically as our program runs. However, we can mimic the features of arrays seen above using other forms of initialisation such as\nstd::vector&lt;int&gt; zeros(10);\nwhich defines a vector of ints called zeros which has 10 elements all initialised to the default value of 0, or we could use\nstd::vector&lt;int&gt; ones(10,1);\nwhich instead initialises them all to 1. We can also explicitly define the elements of a vector on initialisation as\nstd::vector&lt;int&gt; primes = {2, 3, 5, 7, 11, 13, 17}; \nor just as\nstd::vector&lt;int&gt; primes {2, 3, 5, 7, 11, 13, 17}; \nwithout the = sign. Once populated we can access elements of a vector using the same [.] indexing as with arrays. This example highlights this feature:\n#include &lt;iostream&gt;\n#include &lt;vector&gt; // Add this header to use vectors\n\nint main() \n{\n  static const int num = 10; // Define number of elements \n  std::vector&lt;int&gt; squares(num);  // Creates a vector with num elements.\n  \n  for (int i = 0; i &lt; num; i++)\n  {\n    squares[i] = i * i;  // Vector element indexing.\n    std::cout &lt;&lt; \"The square of \" &lt;&lt; i &lt;&lt; \" is \" &lt;&lt; squares[i] &lt;&lt; std::endl;\n  }\n  \n  return EXIT_SUCCESS;\n}\nWe can also use the at() method to access and change elements of a vector, meaning we could replace line 15 above with\nsquares.at(i) = i*i;\nThe slight preference for this approach is that at() throws an exception whenever the element is out of bound, while [.] gives a garbage value.\nNotice also in line 6 we used a static const int to define at compile time the size of the vector like we would for arrays. This is not mandatory for vectors. The same code can work equally well using a user specified size at runtime here:\n#include &lt;iostream&gt;\n#include &lt;vector&gt; // Add this header to use vectors\n\nint main() \n{\n  int num = 0; // Will store number of elements\n  std::cout &lt;&lt; \"Number of elements num = \";\n  std::cin &gt;&gt; num; \n  std::cout &lt;&lt; std::endl;\n  \n  std::vector&lt;int&gt; squares(num);  // Creates a vector with num elements.\n  \n  for (int i = 0; i &lt; num; i++)\n  {\n    squares[i] = i * i;  // Vector element indexing.\n    std::cout &lt;&lt; \"The square of \" &lt;&lt; i &lt;&lt; \" is \" &lt;&lt; squares[i] &lt;&lt; std::endl;\n  }\n  \n  return EXIT_SUCCESS;\n}\nWe can add or append new elements to a vector allowing its size to grow by using the push_back() method of the vector class. For example:\nprimes.push_back(19);\nwill add 19 to our list of prime numbers primes defined earlier. Hence we could replace lines 11-17 in our listing with\nstd::vector&lt;int&gt; squares;  // Creates empty vector\n  \n  for (int i = 0; i &lt; num; i++)\n  {\n    squares.push_back(i*i);  // Append to the end\n    std::cout &lt;&lt; \"The square of \" &lt;&lt; i &lt;&lt; \" is \" &lt;&lt; squares[i] &lt;&lt; std::endl;\n  }\nLikewise we can delete the last element of a vector using the pop_back() method, so\nprimes.pop_back();\nwill remove the 19 we just added to primes.\n\nIt useful to list some other key method of the vector class:\n\nsize()\nThis returns the number of elements in a vector.\n\n\nreserve(n)\nThis will reserve storage in a vector for n elements. This does not create any elements so the size of the vector is unchanged. However, preallocating storage in this way before you need it can have dramatic speed benefits.\n\n\ncapacity()\nThis returns the number of elements for which storage has been reserved, which is equal or greater than size().\n\n\nclear()\nThis deletes all elements, so size() is zero, but leaves the capacity() unchanged.\n\n\nempty()\nThis returns true if size() is zero.\n\n\nThere are more features, including iterators, which make the vector class an indispensable tool in C++.",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "arrays_vectors.html#multidimensional-vectors",
    "href": "arrays_vectors.html#multidimensional-vectors",
    "title": "Arrays and Vectors",
    "section": "Multidimensional vectors",
    "text": "Multidimensional vectors\nThe last example we will examine is how to implement a multidimensional vector. Specifically, this is achieved by creating a vector of vectors. The following example illustrates this by updating our matrix multiplication example from earlier:\n#include &lt;iostream&gt;\n#include &lt;vector&gt; // Add this header to use vectors\n\nint main() \n{\n  // Define explicitly a 3x3 matrix A\n  std::vector&lt;std::vector&lt;float&gt;&gt; A = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; \n  int Arows = A.size(); // Number of rows in A\n  int Acols = A[0].size();  // Number of columns in A\n  \n  // Define explicitly a 3x2 matrix B\n  std::vector&lt;std::vector&lt;float&gt;&gt; B = { {4, 1}, {5, 2}, {1, 0} }; \n  int Brows = B.size(); // Number of rows in B - must be equal to Acols\n  int Bcols = B[0].size(); // Number of columns in B\n  \n  // Define a 3x2 matrix of zeros C\n  std::vector&lt;std::vector&lt;float&gt;&gt; C(Arows, std::vector&lt;float&gt; (Bcols, 0)); \n\n  for(int i=0; i&lt;Arows; i++) \n  {\n    for(int j=0; j&lt;Bcols; j++) \n    {\n      for(int k=0; k&lt;Acols; k++) \n      {\n        C[i][j] += A[i][k]*B[k][j];\n      }\n      std::cout &lt;&lt; C[i][j] &lt;&lt; \" \"; // Display result\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n  \n  return EXIT_SUCCESS;\n}\nThe crucial lines here are\nstd::vector&lt;std::vector&lt;float&gt;&gt; A = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; \nstd::vector&lt;std::vector&lt;float&gt;&gt; C(Arows, std::vector&lt;float&gt; (Bcols, 0)); \nBoth lines use std::vector&lt;float&gt;, which is a vector of floats, as the &lt;type&gt; for the vector2. This creates a vector of vectors. In the first case show that explicit nested {.} initialisation possible with multidimensional arrays is also is allowed for multidimensional vectors. The second case nests the bracketed initialisation (&lt;size&gt;, &lt;value&gt;) of vectors, so C(Arows, std::vector&lt;float&gt; (Bcols, 0)) initialises C with Arows of vectors each of Bcols size themselves initialised to zero. Note that line 25 of the listing we use the [.][.] indexing to access elements of the 2d vector. The generalisation to higher dimensional vectors follows identically by constructing vectors of vectors of vectors using a declaration with a form like:\nstd::vector&lt;std::vector&lt;std::vector&lt;float&gt;&gt;&gt; D;\nThere are other container classes besides vectors in the standard C++ library which you will encounter next year. However, hopefully this brief introduction makes it clear that vectors are a user friendly and safe way to handle numerical data in C++. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "arrays_vectors.html#footnotes",
    "href": "arrays_vectors.html#footnotes",
    "title": "Arrays and Vectors",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nOne way around this is to use static const int as we will describe shortly.↩︎\nYou may find that older C++ compilers will complain about &gt;&gt; needing a space between the &gt;’s. Just use a flag like -std=c++17 to tell the compiler to assume a more recent standard of C++ to avoid this.↩︎",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "using_shell.html",
    "href": "using_shell.html",
    "title": "Using the shell",
    "section": "",
    "text": "Essentially all high-performance computing clusters use a Unix-based operating system (often a variant of Linux) and your interactions with such resources will almost certainly be via command line instructions. It is therefore essential we start with an overview of the some useful commands for navigating the filesystem.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Using the shell"
    ]
  },
  {
    "objectID": "using_shell.html#basic-shell-usage",
    "href": "using_shell.html#basic-shell-usage",
    "title": "Using the shell",
    "section": "Basic shell usage",
    "text": "Basic shell usage\n1. Present working directory: To see the path of the current directory\npwd\n/Users/username/Documents/course\n2. List files and directories: To list the contents of the current directory\nls \ntest           data.zip\nfile1          \nTo list all the details of the current directory contents type\nls -al \ndrwx------    3 username  staff     96  8 Jul  2019 test\n-rwxr-xr-x   43 username  staff   1376  4 Oct  2018 file1\n-rwxrwxrwx    3 username  staff     96  3 Apr  2020 data.zip\nThe character being d tells that test is a directory while the - for the rest of the contents indicates they are regular files. The string of characters like rwxr-xr-x is the permission string, and the last entry is the filename.\n3. Change directory: To change directory to test listed above use the cd command\ncd test\nTo go back the next directory one level up\ncd ..\nThis should return us to our original directory.\n4. Create a new directory: To create a new directory called my_new_folder\nmkdir my_new_folder\n5. Remove a file: To delete a specific file called file.txt\nrm file.txt\n6. Remove a directory: To delete a directory my_old_folder and its contents\nrm -r my_old_folder\nThe -r flag indicates that you want to recursviely remove the directory and any files or subdirectories inside it.\n7. Move or rename a file: To move a file to a new location and rename it\nmv old_file.txt new_location/new_name.txt\n8. Copy a file: To copy a file to a new location\ncp file.txt /path/to/destination/\n9. Copy a directory: To copy a directory and its contents\ncp -r source_directory/ destination_directory/\n10. Create a new file: To create an empty file\ntouch newfile.txt\n11. Edit a file: To open a file in a text editor like nano for editing\nnano file.txt\n12. View the contents of a file: To display the contents of a file in the terminal\ncat file.txt\n13. Search for text in a file: To search for specific text in a file\ngrep \"search_term\" file.txt\n14. Display disk usage: To show the disk usage of files and directories\ndu -sh *\n15. Manupilate permissions: To change the permissions on a file file1 so it is executable type use\nchmod +x file1\n16. Access manual: To see the Linux manual for any command (like chmod) use man as\nman chmod\nCHMOD(1)                  BSD General Commands Manual                 CHMOD(1)\n\nNAME\n     chmod -- change file modes or Access Control Lists\n\nSYNOPSIS\n     chmod [-fv] [-R [-H | -L | -P]] mode file ...\n     chmod [-fv] [-R [-H | -L | -P]] [-a | +a | =a] ACE file ...\n     chmod [-fhv] [-R [-H | -L | -P]] [-E] file ...\n     chmod [-fhv] [-R [-H | -L | -P]] [-C] file ...\n     chmod [-fhv] [-R [-H | -L | -P]] [-N] file ...\n\nDESCRIPTION\n     The chmod utility modifies the file mode bits of the listed files as\n     specified by the mode operand. It may also be used to modify the Access\n     Control Lists (ACLs) associated with the listed files.\n     ...\nThis will give an exhaustive list of all the flags and options available for any command. Press [space] to scroll and [control]+[c] to quit.\nFinally, some useful tricks. Use the \\([\\uparrow]\\) and \\([\\downarrow]\\) keys on the keyboard to retrieve previously typed commands so you can avoid typing them in again. Use the [tab] key to auto-complete your commands, for example, cd t + [tab] should auto-complete as cd test.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Using the shell"
    ]
  },
  {
    "objectID": "using_shell.html#anatomy-of-a-c-program",
    "href": "using_shell.html#anatomy-of-a-c-program",
    "title": "Using the shell",
    "section": "Anatomy of a C++ program",
    "text": "Anatomy of a C++ program\nC/C++ programs are written in a plain-text source files conventionally ending with .cpp. For example we could have a file hello.cpp:\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"Hello world!\\n\"; // The main purpose of this program!\n    return EXIT_SUCCESS; // Return value indicating successful execution\n}\nThe first line #include inserts (see shortly) external files into our program, essentially like import in Python. Here we are using it to include the iostream.hpp header file which defines the standard input-output stream C++ library so we can use the console output object std::cout. We then define our main() function, a mandatory function that all C/C++ programs start with. The int keyword simply states that this function returns an integer when finished, specified here by EXIT_SUCCESS on line 6. Line 5 is the only non-trivial command in this program which prints a message to the console.\nNote that all commands in C/C++ are terminated by ;, and blocks of code are delimited using { ... }. Besides this C/C++ is a free-form language meaning that you can put spaces, tabs and line breaks more or less where you want. Unlike Python there is no strict requirement to put commands on different lines or use any indentation, but of course such practices are highly advised.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Using the shell"
    ]
  },
  {
    "objectID": "using_shell.html#comments-and-preprocessor-directives",
    "href": "using_shell.html#comments-and-preprocessor-directives",
    "title": "Using the shell",
    "section": "Comments and preprocessor directives",
    "text": "Comments and preprocessor directives\nThe expression // anywhere in a source file makes everything from then on until the end of the line is a comment. You can add longer comments using /* and / pairs which comment out everything in between even if it spans across many lines. You are encouraged to use comments liberally in your code.\nStatements like #include seen in hello.cpp above are not C/C++ commands. Rather that they are preprocessor directives that start with a hash # symbol and don’t require the terminating semicolon. The C preprocessor is a scripting language allowing macro substitutions of the text in a source file. The most common is the #include directive which inserts the contents of an external header file at that location in the source file.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Using the shell"
    ]
  },
  {
    "objectID": "using_shell.html#compilation-process",
    "href": "using_shell.html#compilation-process",
    "title": "Using the shell",
    "section": "Compilation process",
    "text": "Compilation process\nGiven our plain text source file hello.cpp we proceed to compile this into an executable binary file using the following command line\ng++ hello.cpp -o hello\nHere the -o hello argument specifies that the output of the compilation should be an executable named hello. This file can then be executed as (don’t forget the ./):\n./hello\nHello world!\nWe have therefore written, compiled and ran our first C++ program!\nIt is worth pausing to reflect on what the above compilation process actually did in order to understand just how different it is from just running a python script. Broadly speaking four steps occur when a C++ program is compiled:\n\nPreprocessing: the source file(s) are parsed with all comments being removed and any preprocessor directives are executed.\nCompilation: the source file is then decomposed into a sequence of assembly code instructions.\nAssembly: the asssembly code instructions are then converted into microprocessor specific machine code giving a binary .o object file.\nLinking: The final step is to insert together all the machine code fragments from the object files and external libraries to form a single executable file. In our compilation of hello.cpp above we only see the output from step\nIf you are curious about step 2 we can use the -S flag tells the compiler to stop once compilation into assembly language is complete as\n\ng++ hello.cpp -S -o hello.asm \nHere we have specified the output to be a file called hello.asm which contains the assembly instructions for our program. If you inspect its contents you will probably see something like this:\nmore hello.asm\n        .section        __TEXT,__text,regular,pure_instructions\n        .build_version macos, 12, 0     sdk_version 12, 1\n        .globl  _main                           ## -- Begin function main\n        .p2align        4, 0x90\n_main:                                  ## @main\n        .cfi_startproc\n## %bb.0:\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset %rbp, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register %rbp\n        subq    $16, %rsp\n        movq    __ZNSt3__14coutE@GOTPCREL(%rip), %rdi\n        movl    $0, -4(%rbp)\n        leaq    L_.str(%rip), %rsi\n        callq   __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc\n        xorl    %eax, %eax\n        addq    $16, %rsp\n        popq    %rbp\n        retq\n        .cfi_endproc\n                                        ## -- End function\n        .globl  __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc ## -- Begin function _ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc\n        .weak_definition        __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc\n        .p2align        4, 0x90\n__ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc: ## @_ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc\n        .cfi_startproc\n## %bb.0:\n        pushq   %rbp\n        ...\nLikewise the compilation can also be stopped after step 3 is complete by using the -c flag as\ng++ hello.cpp -c -o hello.o\nOur output now is hello.o which is the object binary file. In this simple case we can complete the full compilation by doing the linking step as:\ng++ hello.o -o hello\nIn the last workshop we will look at more complex programs where our code is distributed across several different files requiring us to perform a multi-step compilation using this -c flag. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Using the shell"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to Introduction to C++",
    "section": "",
    "text": "This self-contained website contains all the materials for the Introduction to C++ part of the SCIF20002 Programming and Data Analysis for Scientists course.\nThis part of the course is an introduction to what is likely to be for many of you a new programming language C++. As we shall see learning C++ will give you a broader perspective on software engineering. Over the course of five sessions, you will acquire the skills to:"
  },
  {
    "objectID": "index.html#requirements",
    "href": "index.html#requirements",
    "title": "Welcome to Introduction to C++",
    "section": "Requirements",
    "text": "Requirements\n\nKnowledge base\nYou will need:\n\nexperience of using editors like VSCode\nconsolidated knowledge of Python\nbasic understanding of programming primitives like looping and conditional branching\n\n\n\nSoftware\nYou will need access to a complete environment with\n\na Unix shell (e.g. a Terminal)\na C++ compiler (gcc/g++)\nsuitable editor (e.g. VSCode).\n\nIn the Noteable environment (e.g. Jupyter Lab), accessible via this link Launch Noteable, provides a browser embedded terminal and already has g++ installed. Details on how to edit C++ source files and create a terminal session are given in the workshop 1 lecture slides.\nHowever, you are encouraged to have your own software development environment installed locally on your machines.Here are some architecture-dependent recommendations:\n\nWindows 11MacOSLinuxChromeOS\n\n\nShell\nThe recommended way to do software development on Windows is to install the Windows Linux Subsystem (WSL, version 2). This installs a well-integrated local Linux distribution. ↗.\nIn brief, you will need to open the Windows Command Prompt in administrator mode by right-clicking and selecting Run as administrator and then type the single command\nwsl --install\nRestart the machine and then launch WSL.\nC++ compiler\nFrom the WSL shell, install the C/C++ compiler with\nsudo apt install gcc\nYou will be prompted to enter the password that you will have set for your WSL user.\nCode editor\nThe simplest option is to install Visual Studio Code and configure it to work with WSL.\nHere is the offical guidance ↗️\n\n\nShell\nThe Mac already has a proper shell, called Terminal.\nIt is useful however to install a package manager that simplifies the installation of software. The most suitable is homebrew.\nTo install it, open a Terminal and type (you can copy and paste the command below)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nC++\nThe Mac already comes with a good compiler installed called clang, with aliases for commands such as gcc and g++.\nYou may want to install a GNU compiler ( the standard gcc compiler that you have, for example, on the Bristol High Performance Computing clusters) you can install it with homebrew using:\nbrew install gcc\nThis will install the latest version of gcc, which you will access with the command gcc-xx where xx is the version number. For example gcc-14.\nCode editor\nYou can install whatever editor you prefer. A simple option is Visual Studio Code, which you can download from this link ↗️\nA telemetry-free version of VSCode can be installed via homewbrew\nbrew install --cask vscodium\n\n\nDepending on the Linux distribution, you may have different package managers to install software. Here we assume a Debian-based distribution such as Ubuntu, where the package manager is apt (or apt-get).\nShell\nAll Linux distributions have an application to launch a shell, often called Terminal.\nC++\nThe C/C++ compilers are normally already installed. If not, just type\nsudo apt-get install gcc\nCode editor\nYou can install whatever editor you prefer, including VSCode ↗️.\nOn Ubuntu, a telemetry-free version of VSCode can be installed via snaps\nsnap install codium --classic\n\n\nChromebooks have a Linux operating system running under the hood.\nIt is possible to access it by activating the Linux development environment, see the documentation ↗️\nYou can then follow the same instructions as Linux users.\n\n\n\nYou should now have the tools to start the first workshop. \\(\\Box\\)"
  },
  {
    "objectID": "workshop5.html",
    "href": "workshop5.html",
    "title": "Workshop 5 - Structures and Objects",
    "section": "",
    "text": "The learning objectives of this workshop are:\n\nTo learn how to define and use structures.\nTo appreciate how a simple object class is defined and implemented in C++.\n\n\n\n\n\n\n\nSummary lecture slides\n\n\n\nHere are the introductory lecture slides for this workshop.\n\n\n\n\n\n\n\n\nExample codes\n\n\n\nSource code for all the examples discussed in the notes for this workshop are available here as a .zip examples.\n\n\nStart this workshop by reading Structures and Objects. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>"
    ]
  },
  {
    "objectID": "simple_c++.html",
    "href": "simple_c++.html",
    "title": "Simple C++ calculation",
    "section": "",
    "text": "For this first workshop we will be considering a simple mathematical calculation of the Mandelbrot set implemented in C++ as mandelbrot.cpp. This code generated the data plotted in Figure 1 below. It is not necessary for you to understand or modify this C++ code today, nor is it essential you have an in-depth understanding of the mathematics of this example. We will be learning much more about the syntax and functionality of C++ code over the next few workshops.\nThe Mandelbrot set calculation is a classic example of an embarrassingly parallel computation. After this workshop you are invited to try out the optional activity Using HPC where the same calculation is performed exploiting parallelism with HPC resources.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Simple C++ calculation"
    ]
  },
  {
    "objectID": "simple_c++.html#computing-the-mandelbrot-set",
    "href": "simple_c++.html#computing-the-mandelbrot-set",
    "title": "Simple C++ calculation",
    "section": "Computing the Mandelbrot set",
    "text": "Computing the Mandelbrot set\nThe shape of the Mandelbort set on the complex plane is a famous example of a fractal – a never-ending pattern of self-similar structures across all length scales.\nSpecifically, the Mandelbrot set is the set of complex numbers \\(c = c_x + {\\rm i}c_y\\) for which the orbit of the origin under iteration of the quadratic map \\[\n    z_{n+1} = z_n^2 + c,\n\\tag{1}\\] remains bounded. So if \\(c\\) is inside the Mandelbrot set then starting from \\(z_0 = 0\\) and repeatedly applying the iteration \\(|z_n|\\) does not diverge with increasing \\(n\\). In practise we usually require that \\(|z_n| \\leq 2\\) as a criterion for being bounded.\nLet’s decompose this calculation in steps:\n\nChoose a suitable region of the complex plane \\(x + {\\rm i}y\\) to examine – the \\(3 \\times 3\\) square \\(-2 \\leq x \\leq 1\\) and \\(-1.5 \\leq y \\leq 1.5\\) is convenient.\nSample \\(N \\times N\\) points \\(c\\) in this region, each of which will form a pixel of the final image of the set.\nFor each pixel iterate the Mandelbrot mapping in Equation 1. Remember that \\(z_n\\) is complex so \\(z_n = x_n + {\\rm i}y_n\\) means that \\(z_n^2 = x_n^2 - y_n^2 + 2{\\rm i}x_ny_n\\).\nThe iteration terminates if \\(|z_n|&gt;2\\), which we take as a signal that the point \\(c\\) lies outside the set. We count the number of iterations \\(q(c)\\) taken before this condition was met and store it for each point \\(c\\) tested.\nTo prevent the iteration running endlessly we also terminate if \\(n(c) = D\\) where \\(D\\) is the maximum iteration count or depth we allow. Points \\(c\\) where \\(n(c)\\) reaches \\(D\\) are deemed to lie inside the Mandelbrot set since they did not diverge for the depth we tested.\n\nFrom this description there are two parameters \\(N\\) and \\(D\\) which determine the resolution of our calculation. Evidently, the larger \\(N\\) is the more we will be able to resolve tiny structure in the set missed if we sample too coarsely. Less obvious is that increasing \\(D\\) also determines how precise the image will be. Some points very close to the set may not meet the divergence condition \\(|z_n| &gt;2\\) until many iterations \\(q &gt; D\\) have been made, so we will incorrectly identify them as inside the set. The interesting feature of this calculation for our purposes is that we can make its computational requirements arbitrarily demanding by increasing \\(N\\) and \\(D\\) and obtain new increasingly complicated and beautiful images. Our aim in this workshop will be to generate a Mandelbrot image of sufficiently resolution and depth. To reach super high resolution images distributing the task over a HPC resource makes sense.\n\n\n\n\n\n\nFigure 1: The Mandelbrot set computed using (a) \\(N=200\\), \\(D=20\\), (b) \\(N=2000\\), \\(D=20\\), (c) \\(N=2000\\), \\(D=200\\), (d) \\(N=2000\\), \\(D=2000\\). The colourmap is based on \\(\\log_{10}n(c)\\) so solid red signifies a point is inside the set, while blue signifies rapid divergence relative to \\(D\\) and colours in between close to the boundary are divergences that occur only after a significant number of iterations.\n\n\n\nSome example images of the Mandelbrot set are shown in Figure 1. The panels (a) to (d) show how increasing \\(N\\) and \\(D\\) alter the resolution and clarity of the image. The best of these pictures highlights some interesting properties of the Mandelbrot set. First, it is a connected set, meaning there is always a path from one point in the set to any other point which traverse only through points in the set. Second, the Mandelbrot set has a finite area but an infinite length perimeter (this curious property is related to the conundrum of what the length of the UK’s coastline actually is if one includes nooks, crannies and crevices in the rocks on all size scales). Third, the set is symmetric about the real axis so if \\(c\\) is in the set then so is its conjugate \\(c^*\\).",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Simple C++ calculation"
    ]
  },
  {
    "objectID": "simple_c++.html#compiling",
    "href": "simple_c++.html#compiling",
    "title": "Simple C++ calculation",
    "section": "C++ implementation",
    "text": "C++ implementation\nHere we introduce a C++ implementation of the Mandelbrot set calculation described above. The purpose of this code today is to provide a simple but interesting example for you to try out compiling, running and processing output as would be performed for any serious scientific calculation.\nThe code itself is relatively short and is listed here:\n// C++ implementation for Mandelbrot set fractals\n\n// To avoid warnings tell the compiler to use a recent standard of C++:\n// g++ -std=c++17 mandelbrot.cpp -o mandelbrot\n// ./mandelbrot 1 20 20 1\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;cmath&gt;\n\nusing std::cout, std::endl;\n\n// Function to compute if a point is inside the Mandelbrot set:\nint mandelbrot(double cx, double cy, int D)\n{\n    double zx = 0.0, zy= 0.0; // Starting point is the origin.\n    double Zx, Zy; // Intermediate complex number.\n    int count = 0; // Iteration counter.\n\n    // If the distance from the origin is greater than 2 \n    // AND the maximum of iterations D is reached, then exit the loop:\n    while ((zx*zx + zy*zy &lt; 4) && (count &lt; D)) {\n        // Calculate Mandelbrot function Z = z*z + c, where z is a complex number:\n        Zx = zx*zx - zy*zy + cx; // Real part of Z.\n        Zy = 2*zx*zy + cy; // Imaginary part of Z.\n\n        // Update z as Z and iterate:\n        zx = Zx;\n        zy = Zy;\n\n        count++; // Increment the iteration counter\n    }\n    return count;\n}\n\n// USAGE:   mandelbrot N, P, D, n\n// N = number of boxes in the complex plane as N x N\n// P = points in each box as P x P\n// D = depth of calculation as the maximum iteration count\n// n = 1, 2, ..., N*N, the number of the box to be computed\n// OUTPUT:  fractal_data_&lt;n&gt;.csv\n\nint main(int argc, char** argv)\n{ \n    double cx, cy; // Coordinates used in main loop.\n    int count; // Counter used in main loop.\n\n    // Checking if number of argument is equal to 4 or not.\n    if (argc &lt; 4 || argc &gt; 5) {\n        cout &lt;&lt; \"ERROR: need 4 input arguments - mandelbrot N P D n\" &lt;&lt; endl;\n        return 0;\n    }\n  \n    // Convert command line inputs from strings to integers:\n    int N = atoi(argv[1]); \n    int P = atoi(argv[2]);\n    int D = atoi(argv[3]);\n    int n = atoi(argv[4]);\n\n    // Fixed total box for computing fractal image is 3x3 with\n    // bottom left corner at (-2,-1.5).\n    double x0 = -2;\n    double y0 = -1.5;\n    double d = 3.0/(N*P-1); // Pixel size d x d.\n\n    // Determine which box along the x and y axis the fractal is to be computed in:\n    int nx = n % N;\n    int ny = floor((n-1)/N);\n    // Corresponding coordinates of the bottom left corner of the box:\n    double left = d*P*nx + x0;\n    double bottom = d*P*ny + y0;\n  \n    std::string filename = \"fractal_data_\"; // Fixed filename prefix.\n    filename += std::to_string(n); // Append the box number to the data file.\n    filename += \".csv\"; // Save as a comma separated value text file.\n    std::ofstream myfile (filename);\n    if (myfile.is_open()) {\n        // Scanning every point in the box:\n        for (int x=0; x&lt;P; x++) {\n            for (int y=0; y&lt;P; y++) {\n                // Coordinate of constant c \n                cx = x*d + left; // Real part of c.\n                cy = y*d + bottom; // Imaginary part of c.\n\n                // Iterate z = z*z + c with starting point at the origin:\n                count = mandelbrot(cx,cy,D);\n                // Save data as a line in a comma separated text file:\n                myfile &lt;&lt; cx &lt;&lt; \",\" &lt;&lt; cy &lt;&lt; \",\" &lt;&lt; count &lt;&lt; endl;\n            }\n        }\n        myfile.close();\n        cout &lt;&lt; \"Mandelbrot set computation complete\" &lt;&lt; endl;\n    }\n    else cout &lt;&lt; \"Unable to open file\" &lt;&lt; endl;\n\n    return EXIT_SUCCESS;\n}\nIt performs precisely the calculation of the Mandelbrot set as outlined in the last section.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Simple C++ calculation"
    ]
  },
  {
    "objectID": "simple_c++.html#compiling-and-running-the-code",
    "href": "simple_c++.html#compiling-and-running-the-code",
    "title": "Simple C++ calculation",
    "section": "Compiling and running the code",
    "text": "Compiling and running the code\nIn the bash terminal We now compile this code using the GNU C-compiler as:\ng++ -std=c++17 mandelbrot.cpp -o mandelbrot\nThis command should run without any output or errors if your terminal is currently located at the same directory you put the code. Should you examine the contents of the directory after compilation you will find a file mandelbrot present. This is the executable binary for the compiled C++ code.\nThe code accepts four command-line arguments of the form mandelbrot N P D n. where N is the partitioning of the complex plane into N \\(\\times\\) Nboxes. When running on your own computer we will only ever use N=1 box. The parameter P then specifies that each box is to be divide into P \\(\\times\\) P points. Thus we are sampling the \\(3 \\times 3\\) square of the complex plane with NP \\(\\times\\) NP points in total. Each point is computed to a maximum of D iteration depth. Finally, the parameter n specifies which of the \\(1,2,\\dots,\\) N\\(^2\\) boxes this particular instances of the code is to compute.\nWe can test that the Mandelbrot code runs by typing:\n./mandelbrot 1 20 20 1\nMandelbrot set computation complete\nwhich specifies that it uses just 1 box with a \\(20\\times 20\\) grid, an iteration depth of 20 and computes the points inside 1 box. When the code finishes you will find a file fractal_data_1.csv has appeared in your directory. You can examine its contents using the more command as\nmore fractal_data_1.csv\n-2,-1.5,1\n-2,-1.34211,1\n-2,-1.18421,1\n-2,-1.02632,1\n-2,-0.868421,1\n-2,-0.710526,1\n-2,-0.552632,1\n-2,-0.394737,1\n-2,-0.236842,1\n-2,-0.0789474,1\n-2,0.0789474,1\n-2,0.236842,1\n-2,0.394737,1\n-2,0.552632,1\n-2,0.710526,1\n-2,0.868421,1\n-2,1.02632,1\n-2,1.18421,1\n-2,1.34211,1\n-2,1.5,1\n-1.84211,-1.5,1\n-1.84211,-1.34211,1\n-1.84211,-1.18421,1\nfractal_data_1.csv\nwhere scrolling down and exiting just like with the manual pages earlier. As promised the data is saved in the format where each row stores \\(c_x, c_y, n(c)\\) with the filename fractal_data_1.csv. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Simple C++ calculation"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "This background information document will provide you with a concise introduction to functions in C/C++.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#what-are-functions",
    "href": "functions.html#what-are-functions",
    "title": "Functions",
    "section": "What are functions?",
    "text": "What are functions?\nBy now, you know that it is easy to make mistakes when writing programs. The best-practice approach at minimising these ‘bugs’ is called modular programming. The key elements of this approach is to:\n\nIdentify the structure of the problem, and split it into tasks.\nWrite code for the tasks one at a time.\nTest each task independently.\n\nWe can use comments, indentations and judicious variables names in our source code to best reflect these separate sub-tasks, but by far the most useful programming concept for this purpose is that of functions. We have so far not made use of functions so our codes have been long sequences of commands1. If we continued this approach for more complex problems our codes would become very long and unwieldy. Moreover we would likely notice that many blocks of code have a similar structure. Using functions allows us to identify commonalities between tasks and extract sub-tasks as a self-contained reusable units. The end result is much more elegant and logical piece of code.\nWe have already made use of some functions, for example sqrt() from &lt;cmath&gt; library. This already illustrates that we can treat functions as black boxes. We don’t need to know the precise implementation of a function. Rather we need a function specification that tells us (a) the type of input that is required/allowed, (b) what the function does with the input, and (c) what output (if any) is returned. So for sqrt(x) this is take a numerical input x, which could be int, float or double, compute its square-root, and return the result as a double. Once you have written a function, it should then be tested (debugged) thoroughly preferably in all contexts. A ‘black box’ is only useful insofar as it is reliable. Once you have a working function, you can build a hierarchy: write new functions that depend on the functions you’ve already written. This is how all software is developed.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#defining-a-function",
    "href": "functions.html#defining-a-function",
    "title": "Functions",
    "section": "Defining a function",
    "text": "Defining a function\nThe syntax for defining a C/C++ function is:\n    return_type &lt;function_name&gt;(arguments)\n    {\n\n        block of code\n\n        return return_value;\n\n    }\nIn fact every piece of code we have written so far has technically been a function following this definition:\nint main()\n{\n    // Our code was always put here\n    \n    return EXIT_SUCCESS;\n}\nThus main() itself is a function with an integer return type, but it is a special mandatory function which is always executed first in any program. So far we have always defined main() as having no input arguments. We will see next week it can have some fixed input arguments corresponding to command line inputs. Here is a definition of a new function square() that calculates the square of a double:\ndouble square(double x)\n{\n    return x * x; // Do the calculation and return the value on the same line\n}\nJust as a function doesn’t necessarily have to have an input it also doesn’t have to have a return a value. In this case their return type is stated to be void, for example\nvoid display_message()\n{\n    std::cout &lt;&lt; \"This function does nothing but display this message!\" &lt;&lt; \"\\n\";\n    // No return statement is needed here\n}\nHere is a definition of another function sum() that returns the sum of two integers, so has two input arguments:\nint sum(int a, int b)\n{\n    int c = a + b; // Add up the inputs and assign to a local variable\n    return c; // Return the value of the local variable\n}\nNotice that in sum() we have also defined a new variable c inside the function itself. We will discuss this more shortly. Obviously square() and sum() are very simple functions. However, we can define functions with any number of arguments of any type, including structures, and you can put as many lines of code as you want within the function. This allows functions to encapsulate highly non-trivial tasks. For readability though it is worth considering breaking large functions (more than 100’s of lines of code) into a set of smaller, more digestible functions.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#calling-a-function",
    "href": "functions.html#calling-a-function",
    "title": "Functions",
    "section": "Calling a function",
    "text": "Calling a function\nHaving defined a function, as above, how do you go about using it in a program? You can call a function by using its name, and by passing arguments within round brackets ( ), e.g. square(x). One possible form of a program illustrating this is:\n#include &lt;iostream&gt;\n\ndouble square(double x)\n{\n    return x * x; // Here we just do the computation in the return line\n}\n\nint main() \n{\n    double x, xsq;\n    \n    std::cin &gt;&gt; x; // Read in a value\n    xsq = square(x); // Square its value using our function\n    std::cout &lt;&lt; x &lt;&lt; \" squared is \" &lt;&lt; xsq &lt;&lt; \"\\n\"; // Display answer\n    \n    return EXIT_SUCCESS;\n}\nNotice we put the function definition at the top of the source file outside main(). This is because the C/C++ compiler will read the code from the top of the file to the bottom. It needs to have seen the definition of square() before any calls to the function are made. However, sometimes in complex codes it can be difficult, or even impossible, to define a function before it is called because you may have many interdependent functions calling each other. To solve this problem, C/C++ allows you to declare a function separately from where it is defined. Declaring a function means specifying its name, arguments and return type, but no implementation code. We can rewrite our code as:\n#include &lt;iostream&gt;\n\ndouble square(double x); // Declaration of the function\n\nint main() \n{\n    double x, xsq;\n    \n    std::cin &gt;&gt; x; // Read in a value\n    xsq = square(x); // Square its value using our function\n    std::cout &lt;&lt; x &lt;&lt; \" squared is \" &lt;&lt; xsq &lt;&lt; \"\\n\"; // Display answer\n    \n    return EXIT_SUCCESS;\n}\n\ndouble square(double x) // Definition of the function\n{\n    return x * x; // Our implementation\n}\nNote that the name, argument types and return types of the declaration and definition must all match perfectly otherwise the compiler will complain.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#scope-of-variables",
    "href": "functions.html#scope-of-variables",
    "title": "Functions",
    "section": "Scope of variables",
    "text": "Scope of variables\nA crucial part of functions is variable scope. Remember that in C/C++ any variables declared inside a block enclosed by { ... } are defined only within the scope of that block. Specifically, they are local to that block and cannot be accessed outside of it. The same rule applies to functions. Any variables declared inside them are local variables, like c in sum() above, and are inaccessible outside the function. Unlike a block of code, which can access everything defined in the block outside of it, a function can only access what you pass to it as arguments, and the calling block of code will only see the returned value. This increased insulation makes functions very useful for avoiding accidental contamination in your code. As such different functions can have local variables with the same name because they are ‘inside different black boxes’.\nIn C/C++ all variables passed as arguments to a function are passed-by-value. Suppose we rewrote our program using square() as:\n#include &lt;iostream&gt;\n\ndouble square(double x); // Declaration of the function\n\nint main() \n{\n    double x, xsq;\n    \n    std::cout &lt;&lt; \"Enter a value:\" &lt;&lt; std::endl;\n    std::cin &gt;&gt; x; // Read in a value\n    xsq = square(x); // Square its value using our function\n    std::cout &lt;&lt; x &lt;&lt; \" squared is \" &lt;&lt; xsq &lt;&lt; \"\\n\"; // Display answer\n    \n    return EXIT_SUCCESS;\n}\n\ndouble square(double z) // Definition of the function\n{\n    double y = z * z; // Implement using a local variable\n    z = 2*y; // Now modify the input variable\n    return y; \n}\nA few changes have been made here. First, the implementation of square() calls its input z rather than x as in the declaration in line 3. This makes no difference since the declaration does not care about variables names, only their types2. The reason for doing this is so it is clearer that the input variable for square() is not the same variable as the one given as its argument in the function call on line 10. The variable z inside square() is a new variable local to this function whose value is initialised with the value of the variable x in main(). It should then be clear then that line 19 inside square() does not alter at all the value of the variable x in main(). Functions cannot alter the value of their inputs since the way we have defined them so far are pass-by-value. This could be an issue, for example if we passed a large vector object since its contents would get deep-copied every time we ran the function. Moreover, there will be occasions where we want functions that can alter their inputs. To do this we need to pass-by-reference.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#passing-arguments-by-reference",
    "href": "functions.html#passing-arguments-by-reference",
    "title": "Functions",
    "section": "Passing arguments by reference",
    "text": "Passing arguments by reference\nWe can alter our definition of functions so variable are passed by reference. Here is a simple example of a declaration for a function which swaps the value of two integers:\nvoid swap_integers(int& a, int& b);\nBy inserting & in front of the arguments we are explicitly telling the compiler that a and b should be passed-by-reference. The function do not need a return value since it can modify the input variables directly. Here is a program implementing and using this function:\n#include &lt;iostream&gt;\n\nvoid swap_integers(int& a, int& b); // Declaration of the function\n\nint main() \n{\n    int x = 67; // Declare and initialise two integers\n    int y = 24;\n    \n    std::cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \" and y = \" &lt;&lt; y &lt;&lt; \"\\n\"; // Display variables\n    swap_integers(x, y); // Swap by passing variables themselves\n    std::cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \" and y = \" &lt;&lt; y &lt;&lt; \"\\n\";  // Display them again\n    return EXIT_SUCCESS;\n}\n\nvoid swap_integers(int& a, int& b)  // Definition of the function\n{ \n    int local_var; // A local variable is needed to perform a swap\n    local_var = a; \n    a = b; \n    b = local_var;\n}\nNotice that we can treat a and b in our implementation of the function as just normal local integer variables.\nThe examples above used primitive data types, but the same properties apply to structures and objects (see next week). Here is a simple example of a program that uses function which accepts a vector object and normalizes it:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\n// Declaration functions:\ndouble magnitude (std::vector&lt;double&gt; inputVector);  // Vector passed by value\ndouble normalize (std::vector&lt;double&gt;& inputVector); // Vector passed by reference\n\nint main() \n{\n    // Declare and initialise components of a vector:\n    std::vector&lt;double&gt; myVector{-0.82,1.23,0.77,-13.21}; \n    \n    double mag = normalize(myVector); // Normalize returns original magnitude\n    // Display the magnitude of original vector:\n    std::cout &lt;&lt; \"|myVector| = \" &lt;&lt; mag &lt;&lt; std::endl;  \n    mag = magnitude(myVector); // Evaluate the magnitude again\n    // Display the magnitude of the normalized vector:\n    std::cout &lt;&lt; \"|normalize(myVector)| = \" &lt;&lt; mag &lt;&lt; std::endl;  \n    return EXIT_SUCCESS;\n}\n\n// Definition of functions:\ndouble magnitude(std::vector&lt;double&gt; inputVector)  \n{ \n    double result = 0.0;\n    for (int i=0; i&lt;inputVector.size(); i++) \n    {\n        result = result + inputVector[i] * inputVector[i];\n    }\n    return sqrt(result);\n}\n\ndouble normalize(std::vector&lt;double&gt;& inputVector) \n{ \n    double mag = magnitude(inputVector); \n    for (int i=0; i&lt;inputVector.size(); i++) \n    {\n        inputVector[i]  = inputVector[i]/mag; // Overwrite the vector components\n    }\n    return mag; // Return the original magnitude\n}\nNote that in magnitude() we passed the input vector object by value and a deep-copy of myVector was made. In normalize() the vector myVector was passed by reference explicitly so the function has access to the original data and can modify it directly. In main() we confirm that its magnitude has indeed been made unity by normalize().",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#function-overloading",
    "href": "functions.html#function-overloading",
    "title": "Functions",
    "section": "Function overloading",
    "text": "Function overloading\nThere will be some occasions where we might have several different declarations of the same function. This is called overloading a function and is permitted so long as each declaration has a distinct set of arguments and data types allowing the compiler to identify which instance of a function is being used. Earlier we constructed the sum() defined for int’s. Clearly the same task may be need for double’s so in this program we overload the function:\n#include &lt;iostream&gt;\n\nint sum(int a, int b); // Declared with two int arguments\ndouble sum(double c, double d); // Declared with two double arguments \n\n// Note that it is OK to declare the function twice, even using different argument names\n// (as long as the type are correct).\ndouble sum(double, double); // Indeed, you don't have to specify the argument names.\n\nint main()\n{\n    std::cout &lt;&lt; sum(10, 20) &lt;&lt; std::endl;\n    std::cout &lt;&lt; sum(3.14159, 2.71828) &lt;&lt; std::endl;\n    return EXIT_SUCCESS;\n}\n\n// Definitions must use the same types as the declaration, and must provide argument \n// names since they are referenced in the body of the function. Unlike the type, \n// names don't have to match those used in the declarations (although it's good \n// practice to keep them consistent when names are used.)\n\n// Defined with two int arguments\nint sum(int c, int d)\n{\n    std::cout &lt;&lt; \"Sum of two ints is: \";\n    return c + d;\n}\n\n// Defined with two double arguments\ndouble sum(double a, double b)\n{\n    std::cout &lt;&lt; \"Sum of two doubles is: \";\n    return a + b;\n}\nIf we changed line 12 to sum(10.0, 20) then the above code will not compile since we have not defined a version of the sum() function with mixed double and int arguments. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "functions.html#footnotes",
    "href": "functions.html#footnotes",
    "title": "Functions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEssentially we have been constructing compiled C/C++ ‘scripts’.↩︎\nIndeed you can remove all the variable names from the declaration if you wish.↩︎",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Functions"
    ]
  },
  {
    "objectID": "workshop3.html",
    "href": "workshop3.html",
    "title": "Workshop 3 - Arrays and Vectors",
    "section": "",
    "text": "The learning objectives of this workshop are:\n\nTo learn how to define and use arrays.\nTo master the vector container class for dynamically sized lists.\n\n\n\n\n\n\n\nSummary lecture slides\n\n\n\nHere are the introductory lecture slides for this workshop.\n\n\n\n\n\n\n\n\nExample codes\n\n\n\nSource code for all the examples discussed in the notes for this workshop are available here as a .zip examples.\n\n\nStart this workshop by reading Arrays and Vectors. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>"
    ]
  },
  {
    "objectID": "exercises_wkshp1.html",
    "href": "exercises_wkshp1.html",
    "title": "Workshop exercises",
    "section": "",
    "text": "Starter code\n\n\n\nDownload on to your computer the .zip exercise file for this workshop.\n\n\n\n\n\n\n\n\nTask 1: Using the shell\n\n\n\nUse a terminal to explore your home filespace, e.g. /user/home/&lt;username&gt;, on your computer or Noteable. Make a directory wkshp1 in your home space in the shell and navigate into this directory. Then make two more directories hello and another mandelbrot. Navigate into hello.\n\n\n\n\n\n\n\n\nTask 2: Write and compile your own C++ program\n\n\n\nAs is customary when learning any new language, write your own version “Hello world!\" in C++ and save it in the hello directory. Use the shell to compile it and run it.\n\n\n\n\n\n\n\n\nTask 3: Compile the starter code\n\n\n\nDownload the start zip file, unzip it and copy mandelbrot.cpp to the wkshp1/mandelbrot directory. Compile mandelbrot.cpp and test the executable produced by running a very short calculation, as described in Simple C++ calculation. Examine the output data file in the shell.\n\n\n\n\n\n\n\n\nTask 4: Run a high-resolution calculation\n\n\n\nNow run a much more ambitious high resolution and deep calculation of the Mandelbrot set, for example withN \\(=1\\), P \\(=5000\\), D \\(=2000\\). Then write a Python script to post-process the output file fractal_data_1.csv and generate an image similar to that shown in Fig. 1 in Simple C++ calculation, but with a higher resolution and clarity. You may find the csv Python package useful.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "Workshop exercises"
    ]
  },
  {
    "objectID": "exercises_wkshp2.html",
    "href": "exercises_wkshp2.html",
    "title": "Workshop exercises",
    "section": "",
    "text": "Starter code\n\n\n\nThere is no starter code for this workshop. You need to write these programs from scratch!\n\n\n\n\n\n\n\n\nTask 1: Fibonacci series\n\n\n\nIn the Fibonacci series \\(1, 1, 2, 3, 5, 8, 13, 21, 34, \\dots\\) each number is made by summing the previous two. Create a C++ program that asks the user for an int input \\(N\\) specifying the number of terms of the sequence to be found, computes these terms and outputs them to console. Compute also the ratio of successive pairs of values, output them to the console to 15 d.p. also and confirm it converges to the golden ratio \\(\\phi = \\frac{1}{2}(1 + \\sqrt{5})\\). What happens when \\(N&gt;46\\)?\n\n\n\n\n\n\n\n\nTask 2: Numerical integration\n\n\n\nThe trapezium method for numerical integration of a function \\(f(x)\\) is given by \\[\n\\int_{x_1}^{x_N} f(x) {\\rm d}x = h\\left[\\frac{1}{2}f(x_1) + f(x_2) +  \\dots + f(x_{N-1}) + \\frac{1}{2} f(x_N)\\right]\n+ \\textrm{error term},\n\\tag{1}\\] where \\(h = (x_N - x_1)/(N-1)\\) is the step-size and each sample point is given by \\(x_n = x_1 + (n-1) h\\). This is summarised in Figure 1. Take the function \\(f(x) = 5x^4 + 4x^3 + 3x^2 + 2x + 1\\) and compute its integral analytically between \\(x=0\\) and \\(x=1\\). Now write a C++ program to implement the trapezium method of Equation 1, where the number of steps \\(N\\) is inputted by the user and the result of the integral is printed to 6 d.p. on the screen. Check the answer by hand for \\(N=2\\) and \\(N=3\\) to ensure your code is working. How does \\(N=10\\) compare to the exact answer?\n\n\n\n\n\n\nFigure 1: A schematic of the trapezium method of integration.\n\n\n\n\n\n\n\n\n\n\n\nTask 3: Finding a root\n\n\n\nThe Newton-Raphson approach relies on expanding the function \\(f(x)\\) as a Taylor series, truncating at the first derivative, and rearranging to give: \\[\nx_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)},\n\\tag{2}\\] where \\(f'(x) = \\frac{{\\rm d}}{{\\rm d}x} f(x)\\). By starting with an initial guess \\(x_0\\), Equation 2 can be used to iteratively generate new approximations of the root. Write a C++ program that requests an initial guess and performs the iteration in Equation 2 for the specific case \\(f(x) = \\cos(x) - x^3\\), as shown in Figure 2. Use while loop that tests for convergence with a sufficiently small tolerance to determine the root to 12 d.p. and display the progress on the console.\n\n\n\n\n\n\nFigure 2: Plot of the function \\(f(x)\\) which you should find the root of. By inspection it appears to be around \\(x=0.9\\). If you ask https://www.wolframalpha.com “find root of \\(cos[x] - x\\)” it returns (after requesting more digits) a 20 d.p. solution \\(x ≈ 0.86547403310161444662\\).",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Workshop exercises"
    ]
  },
  {
    "objectID": "exercises_wkshp4.html",
    "href": "exercises_wkshp4.html",
    "title": "Workshop exercises",
    "section": "",
    "text": "Starter code\n\n\n\nDownload on to your computer the .zip exercise file for this workshop.\n\n\n\n\n\n\n\n\nTask 1: Testing the central limit theorem\n\n\n\nTake the example code for random number generation discussed in Useful extras. Now modify this code to sample N = 10,000 numbers from the generator and write them out to a file. Read the data into Python and plot a histogram to confirm the set approximates a uniform distribution between -1 and 1. Next, alter your code to loop over L = 1000 sets of size N = 1000, compute the average of each set and write them to a file. Read this data into Python and plot a histogram of it. What distribution does it approximate?\n\n\n\n\n\n\n\n\nTask 2: Accurately evaluating arctan()\n\n\n\nIt is often necessary to calculate a logarithmic or trigonometric function in a computer program. All computer languages have built-in functions for this, which rely on series expansions. Here you will implement a function arctan() for evaluating \\(\\arctan(x)\\). Download (or upload to BluePebble) the starter code for this question which is a multi-file C/C++ program. The main() function is in the file test_arctan.cpp and is written already. It will call arctan() and test its output for three cases giving a [PASSED] flag only if it is within \\(10^{-8}\\) of the correct answer. A header file arctan.hpp has been written containing the function declaration for arctan() already. Your focus is the source file arctan.cpp which contains the corresponding skeleton implementation of arctan() that currently cheats and uses the standard library atan() implementation. If you run the shell script compile_run.sh then the starter code will be compiled and then executed passing all the tests. Your task is to replace this cheat line with a bespoke arc-tangent implementation.\nIn arctan.cpp you will see that arctan() is overloaded as arctan(x) and arctan(N,x). Start by implementing arctan(N,x) using the Taylor series \\[\n\\begin{aligned}\n    \\arctan(x) = \\sum_{n=0}^{\\tt N} \\frac{(-1)^n}{2n+1}x^{2n+1}, \\quad {\\rm for} \\quad |x| \\leq 1, \\label{eq:taylor}\n\\end{aligned}\n\\] where the input N specifies the number of terms to compute. The other function arctan(x) should be capable of handling \\(|x|&gt;1\\). Fix N = 10 as an internal parameter inside arctan(x) and implement it using the following relations: \\[\n\\begin{aligned}\n    \\arctan(x) = \\left\\{\\begin{array}{cc}\n        \\frac{\\pi}{2} - \\arctan(\\frac{1}{x}) & x &gt; 1 \\\\\n        -\\frac{\\pi}{2} - \\arctan(\\frac{1}{x}) & x &lt; -1\n    \\end{array}\n    \\right. , \\label{eq:relation}\n\\end{aligned}\n\\] by calling arctan(N,x). Is N = 10 sufficient to pass all the tests? Can you increase N to pass test 2?",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Workshop exercises"
    ]
  },
  {
    "objectID": "exercises_wkshp5.html",
    "href": "exercises_wkshp5.html",
    "title": "Workshop exercises",
    "section": "",
    "text": "Starter code\n\n\n\nDownload on to your computer the .zip exercise file for this workshop.\n\n\n\n\n\n\n\n\nTask 1: Finish implementing a 3D vector class\n\n\n\nIn the starter code you will find in vector3d.hpp which declares a 3d vector class, and an incomplete implementation of this class in vector3d.cpp. Study the declarations made in the header file carefully. Your implemention should match these declarations. The purpose of this object is to encapsulate the data of and basic operations on 3d vector specified by its 3 components along the standard cartesian \\(x,y,z\\) axes \\[\n\\begin{aligned}\n    \\vec{v} = \\left(\\begin{array}{c}\n        v_x  \\\\\n        v_y \\\\\n        v_z\n    \\end{array}\\right).\n\\end{aligned}\n\\] Your task is to complete this class by implementing the methods length(), lengthsq(), normalize(), dot(), cross() and angle() as declared in vector3d.hpp. Start with dot(), which given a second 3d vector \\[\n\\begin{aligned}\n    \\vec{u} = \\left(\\begin{array}{c}\n        u_x  \\\\\n        u_y \\\\\n        u_z\n    \\end{array}\\right),\n\\end{aligned}\n\\] should compute the scalar \\(\\vec{v}\\cdot\\vec{u} = v_x u_x + v_y u_y + v_z u_z\\). Using this then define lengthsq() as returning \\(\\vec{v}\\cdot\\vec{v}\\), length() as returning \\(|\\vec{v}| = \\sqrt{\\vec{v}\\cdot\\vec{v}}\\), and angle() as the computation \\[\n\\begin{aligned}\n    \\theta = \\arccos\\left(\\frac{\\vec{v}\\cdot\\vec{u}}{|\\vec{v}|\\, |\\vec{u}|}\\right).\n\\end{aligned}\n\\] You can now define normalize() by simply returning the vector itself divided by its length. Finally, cross() should return a 3d vector with components \\[\n\\begin{aligned}\n    \\vec{v} \\times \\vec{u} = \\left(\\begin{array}{c}\n        v_y u_z - u_y v_z   \\\\\n        v_z u_x - u_z v_x \\\\\n        v_x u_y - u_x v_y\n    \\end{array}\\right).\n\\end{aligned}\n\\] A program test_vector3d.cpp is provided in the starter code which performs example calculations using each of the above methods testing the class implementation. This program is compiled along with vector3d.cpp as\ng++ -std=c++17 vector3d.cpp test_vector3d.cpp -o test_vector3d\nA working implementation of the class should compile successfully and produce the following output:\n./test_vector3d\nTEST: v_new.dir = 1\nTEST: z = v - v_len*dir = (0,0,0)\nTEST: u.v = 0, u.w = 0\nTEST: |r|^2 = 101, and r.u = 101\nTEST: theta = 1.10914 radians\nTEST: r.(-z) = 101\nTEST: z = (0,0,0)\nTEST: u.p = 0\n\n\n\n\n\n\n\n\nTask 2: Compute vector properties\n\n\n\nNow suppose we have two point bodies \\(a\\) and \\(b\\) with masses, positions and velocities \\(m_a, m_b\\), \\(\\vec{r}_a, \\vec{r}_b\\) and \\(\\vec{v}_a,\\vec{v}_b\\), respectively. We want to write code to calculate (i) the distance \\(r = |\\vec{r}_a - \\vec{r}_b|\\) between \\(a\\) and \\(b\\), a unit vector pointing from \\(a\\) to \\(b\\) \\(\\vec{e} =  (\\vec{r}_a - \\vec{r}_b)/r\\), and (ii) the angular momentum of \\(a\\) relative to \\(b\\) as \\(\\vec{L}_a = m_a (\\vec{r}_a - \\vec{r}_b) \\times \\vec{v}_a\\). In the background webpage Structures and Objects a simple structure body was defined for storing all this information. We could proceed by using this structure as it is. However, the kinds of quantities we want to calculate, \\(r\\), \\(\\vec{e}\\) and \\(\\vec{L}_a\\) are those which the 3d vector class in the previous exercise make very straightforward, suggesting that we should replace the arrays by 3d vectors as:\nstruct body {\n    double mass; // Mass\n    vec pos;     // Position vector\n    vec vel;     // Velocity vector\n};\nYour task is to design a body class where the members of the above structure turn into private members. Declare (in body.hpp) and implement (in body.cpp) the class with distance(), direction() and angular_momentum() member functions that compute \\(r\\), \\(\\vec{e}\\) and \\(\\vec{L}_a\\), respectively. Write a test program which creates two bodies with masses \\(m_a = 3.29 \\times 10^{23}\\)kg, \\(m_b = 3.69 \\times 10^{23}\\)kg, position vectors \\[\n\\begin{aligned}\n    \\vec{r}_a = \\left(\\begin{array}{c}\n         5.05 \\times 10^7  \\\\\n       -3.04 \\times 10^7 \\\\\n       -7.12 \\times 10^6\n    \\end{array}\\right)~{\\rm km}, \\quad\n    \\vec{r}_b = \\left(\\begin{array}{c}\n        4.70 \\times 10^7  \\\\\n        2.26 \\times 10^8 \\\\\n        3.57 \\times 10^6\n    \\end{array}\\right)~{\\rm km}\n\\end{aligned}\\] and velocity vectors \\[\\begin{aligned}\n    \\vec{v}_a = \\left(\\begin{array}{c}\n         15.57  \\\\\n         43.96 \\\\\n         2.16\n    \\end{array}\\right)~{\\rm kms}^{-1}, \\quad\n        \\vec{v}_b = \\left(\\begin{array}{c}\n         -22.80  \\\\\n         7.01 \\\\\n         0.71\n    \\end{array}\\right)~{\\rm kms}^{-1}.\n\\end{aligned}\n\\] Compute \\(r\\), \\(\\vec{e}\\) and \\(\\vec{L}_a\\) and display them with units on the console. You should produce an output similar to this:\n./test_body\ndistance = 2.57e+08 km\ndirection = (0.0136,-0.999,-0.0417) km\nL = (-2.76e+31,-5.72e+31,1.36e+33) kgkm^2s^-1",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Workshop exercises"
    ]
  },
  {
    "objectID": "exercises_wkshp3.html#footnotes",
    "href": "exercises_wkshp3.html#footnotes",
    "title": "Workshop exercises",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTechnically, if we wanted to be more memory efficient we could use short int which only use 2 bytes per 3 digit block, or store 4 decimal digits per integer.↩︎\nThis is the same as using numpy.linspace(-1,1,N) in Python.↩︎",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "Workshop exercises"
    ]
  },
  {
    "objectID": "seminar.html",
    "href": "seminar.html",
    "title": "Seminar",
    "section": "",
    "text": "The seminar in this section of the course will tackle an important conceptual difference between C++ and Python. Namely, that C++ code is compiled into an executable while Python code is executed by an interpreter. What difference does this make to performance? Can we improve the performance of Python? Can we mix the two languages to get the best of both worlds? We will attempt to answer these questions in this seminar.\n\n\n\n\n\n\nSeminar slides\n\n\n\nHere are the seminar slides.\n\n\n\n\n\n\n\n\nSeminar codes\n\n\n\nAll the codes discussed are available in this .zip seminar codes.",
    "crumbs": [
      "=> Seminar"
    ]
  },
  {
    "objectID": "seminar.html#compiled-vs-interpreted-code",
    "href": "seminar.html#compiled-vs-interpreted-code",
    "title": "Seminar",
    "section": "",
    "text": "The seminar in this section of the course will tackle an important conceptual difference between C++ and Python. Namely, that C++ code is compiled into an executable while Python code is executed by an interpreter. What difference does this make to performance? Can we improve the performance of Python? Can we mix the two languages to get the best of both worlds? We will attempt to answer these questions in this seminar.\n\n\n\n\n\n\nSeminar slides\n\n\n\nHere are the seminar slides.\n\n\n\n\n\n\n\n\nSeminar codes\n\n\n\nAll the codes discussed are available in this .zip seminar codes.",
    "crumbs": [
      "=> Seminar"
    ]
  },
  {
    "objectID": "workshop2.html",
    "href": "workshop2.html",
    "title": "Workshop 2 - Introduction to C++",
    "section": "",
    "text": "The learning objectives of this workshop are:\n\nTo learn the essential syntax of C++ code.\nTo apply basic variable types, iterative loops and logical conditionals.\nTo read and write data to the screen and a file.\nTo implement some simple mathematical methods in C++.\n\n\n\n\n\n\n\nSummary lecture slides\n\n\n\nHere are the introductory lecture slides for this workshop.\n\n\n\n\n\n\n\n\nExample codes\n\n\n\nSource code for all the examples discussed in the notes for this workshop are available here as a .zip examples.\n\n\nStart this workshop by reading Basics of C++. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>"
    ]
  },
  {
    "objectID": "workshop1.html",
    "href": "workshop1.html",
    "title": "Workshop 1 - The shell and C++",
    "section": "",
    "text": "The learning objectives of this workshop are:\n\nTo learn and use some basic Linux command-line instructions in the shell.\nTo compile some ready-made C++ code.\nPost-process the data in python.\nTo write your own very simple C++ code.\n\n\n\n\n\n\n\nSummary lecture slides\n\n\n\nHere are the introductory lecture slides for this workshop.\n\n\nStart this workshop by reading Using the shell. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>"
    ]
  },
  {
    "objectID": "intro_to_c++.html",
    "href": "intro_to_c++.html",
    "title": "Basics of C++",
    "section": "",
    "text": "This background information document will provide you with a concise introduction to basic C++ syntax.",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#variable-types",
    "href": "intro_to_c++.html#variable-types",
    "title": "Basics of C++",
    "section": "Variable types",
    "text": "Variable types\nC/C++ is a statically and strictly typed language. Statically means variables must be defined as a type at compile time, while strictly means that the compiler will throw an error if you try to assign data of the wrong type to a variable1. Consequently C/C++ compilers requires that the name and type of any variable is defined before it is used. The primitive data types available in C/C++ are:\n\nint integers (at least 16 bits, but can be 32 bits or 64 bits)\nchar character (8 bits)\nfloat single precision floating point (32 bits)\ndouble double precision floating point (64 bits)\nboolean true or false (often 8 bits because CPU’s address memory in bytes)\n\nVariables are declared using statements like this:\nint i, j, k;\nfloat speed, distance;\nThis give us three variables i, j, k for storing integer values, and two speed, distance for storing floating point numbers. In scientific computing applications we will normally always use double to ensure sufficient accuracy. We can initialise variables with values when declaring them using the assignment operator = as:\ndouble pi = 3.14159;\nNote that C/C++ is case sensitive so pi is different to Pi and PI.\nSome declarations of basic types can be modified with additional keywords:\n\nsigned, unsigned, short, long.\n\nUsing these we can modify the range of values that primitive variables can take. Some of the allowed modifications are shown in Tbl. 1. Since the modified type unsigned int can only be non-negative they are useful for counting or iterating inside loops. A weirdly named variant of unsigned integers which you may also encounter is size_t, which is effectively an unsigned integer but with a maximum size guaranteed to be large enough to describe the size in bytes of any object or array - we will use this next week.\n\n\nRange of modified primitive data types in C/C++. The precise values given above can vary between compilers. For example some CPUs support 10 byte = 80 bit long double types.\n\n\nData type\nSize (in bytes)\nRange\n\n\n\n\nshort int\n2\n-32,768 to 32,767\n\n\nunsigned short int\n2\n0 to 65,535\n\n\nunsigned int\n4\n0 to 4,294,967,295\n\n\nint\n4\n-2,147,483,648 to 2,147,483,647\n\n\nlong int\n4\n-2,147,483,648 to 2,147,483,647\n\n\nunsigned long int\n4\n0 to 4,294,967,295\n\n\nlong long int\n8\n-(\\(2^{63}\\)) to (\\(2^{63}\\))-1\n\n\nunsigned long long int\n8\n0 to 18,446,744,073,709,551,615\n\n\nsigned char\n1\n-128 to 127\n\n\nunsigned char\n1\n0 to 255\n\n\nfloat\n4\n\\(\\pm(1.18\\times 10^{-38}\\) to \\(3.40\\times 10^{38})\\)\n\n\ndouble\n8\n\\(\\pm(2.23\\times 10^{-308}\\) to \\(1.80\\times 10^{308})\\)\n\n\n\n\nAnother modifier is const which can be applied to any variable for example as:\nconst double pi = 3.14159;\nand indicates that its value cannot be changed at run-time - the compiler will throw an error if your code makes any such attempt. You can make an even stronger statement of constancy by using static const which tells the compiler to treat it differently from normal variables.",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#arithmetic-expressions",
    "href": "intro_to_c++.html#arithmetic-expressions",
    "title": "Basics of C++",
    "section": "Arithmetic expressions",
    "text": "Arithmetic expressions\nWe can form expressions consisting of variables and constants connected by an operator. For example the assignment =, addition +, subtraction -, multiplication and division operators / have usages like this:\nx = 1;     // sets x to 1\nx = 3*y;   // sets x to 3 times the value of y\nx = y+1;   // sets x to 1 more than y\nx = x+1;   // increases x by 1\nx = pi/2;  // sets x to pi (defined previously) divided by 2  \nx = y-1;   // sets x to 1 less than y\nC/C++ also has some very compact short-cuts:\nx++;       // also increases x by 1\nx += 5;    // increases x by 5\nx *= 3;    // triples the value of x\nx /= y;    // set x to be x divided by y\ny = x++;   // set y to x and then increase x by 1\ny = ++x;   // increases x by 1 then set to y  \nx = 5%3;   // sets x to the remainder of 5 divided by 3\nx--;       // decrease x by 1\nx %= 2;    // set x to be remainder of x divided by 2",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#maths-functions",
    "href": "intro_to_c++.html#maths-functions",
    "title": "Basics of C++",
    "section": "Maths functions",
    "text": "Maths functions\nSince C/C++ is a light-weight language many basic mathematical functions like \\(\\sin(x)\\) are not core parts of the language. Instead they are additional functions written in C/C++ as a part of the standard libraries which we can access by adding #include &lt;cmath&gt; at the top of our source file. In particular you will find the following useful functions:\n\nabs(x), returns the absolute value of x\nacos(x), returns the arccosine of x\nasin(x), returns the arcsine of x\natan(x), returns the arctangent of x\ncbrt(x), returns the cube root of x\nceil(x), returns the value of x rounded up to its nearest integer\ncos(x), returns the cosine of x\ncosh(x), returns the hyperbolic cosine of x\nexp(x), returns the value of \\(e^{\\tt x}\\)\nfabs(x), returns the absolute value of a floating x\nfloor(x), returns the value of x rounded down to its nearest integer\npow(x, y), returns the value of x to the power of y\nsin(x), returns the sine of x (in radians)\nsinh(x), returns the hyperbolic sine of a double x\ntan(x), returns the tangent of an angle x\ntanh(x), returns the hyperbolic tangent of a double x\n\nUse of these functions is a crucial part of scientific computing. Here is a simple example of some usage:\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nint main()\n{\n    double x = 0.91211;\n    double y, z;\n    \n    y = exp(-acos(x));\n    z = cbrt(fabs(atan(x)));\n    std::cout &lt;&lt; \"Answer = \" &lt;&lt; z &lt;&lt;  std::endl;\n    \n    return EXIT_SUCCESS; \n}",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#sec:console",
    "href": "intro_to_c++.html#sec:console",
    "title": "Basics of C++",
    "section": "Outputting to the console",
    "text": "Outputting to the console\nWe saw earlier in hello.cpp that we can output to the console via the insertion operator &lt;&lt; into the std::cout object2. We can concatenate multiple pieces of information using this in a sequence:\nint M = 13;\nfloat G = 5.91;\nchar X = 'P';\n     \nstd::cout &lt;&lt; \"M = \" &lt;&lt; M &lt;&lt; \" and G = \" &lt;&lt; G &lt;&lt; \" with X = \" &lt;&lt; X;\nwhich outputs\nM = 13 and G = 5.91 with X = P\nWe can end a line by inserting std::endl so\nstd::cout &lt;&lt; \"M = \" &lt;&lt; M &lt;&lt; std::endl;\nstd::cout &lt;&lt; \" and \" G = \" &lt;&lt; G &lt;&lt; \" with X = \" &lt;&lt; X;\nwould output instead\nM = 13\n and G = 5.91 with X = P\nEqually you can insert the newline character \"\\n\" to achieve the same effect.\nIn scientific computing we will often want to control the formatting of floating point numbers. There are 3 formats: fixed, scientific and general. Fixed format always has a number, decimal point, and the fractional part comprising of 6 digits by default, no matter how big the number gets, so \\(6.02 \\times 10^{17}\\) would be displayed as 602000000000000000.000000. This type of format is switched on by making the insertion:\nstd::cout &lt;&lt; std::fixed;\nand is then set for all subsequent insertions. In scientific format \\(6.02 \\times 10^{17}\\) would instead be displayed instead as 6.020000e+17. Again 6 decimal digits are the default. This type of format is switched on by making the insertion:\nstd::cout &lt;&lt; std::scientific;\nGeneral format is a mix of fixed and scientific formats. If the number is small enough, fixed format is used. If the number gets too large, the output switches over to scientific format. General format is the default format for floating point values.\nTo make fine-tuning modifications to the output stream we need to include a further header file #include &lt;iomanip&gt;. With this we can change the number of digits displayed using the following modifier insertion:\nstd::cout &lt;&lt; std::setprecision(3);\nwhich here restricts it to 3 digits for all subsequent insertions. Note that precision is the total number of digits, meaning that 3.14159 would be displayed as 3.14, while 0.98121 would be displayed as 0.981. To ensure the display of text has minimum width in characters the following modifier insertion can be used:\nstd::cout &lt;&lt; std::setw(20);\nwhich in this case ensures at least a 20 character output. Note this modifier only effects the next insertion made and must be restated if required for multiple outputs. This full listing shows examples of number formatting:\n#include &lt;iostream&gt; // Needed for cout, endl, fixed, scientific\n#include &lt;iomanip&gt; // Needed for setprecision and setw\n\nint main()\n{\n  double small = 3.1415926535897932384626; // More digits than double can handle!\n  double large = 6.02e17; // Note we can initialise using scientific notation\n  float whole = 2.000000000;\n\n  std::cout &lt;&lt; \"Some values in (default) general format\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"small:  \" &lt;&lt; small &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"large:  \" &lt;&lt; large &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"whole:  \" &lt;&lt; whole &lt;&lt; std::endl &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; std::scientific; // Switch format mode to scientific\n\n  std::cout &lt;&lt; \"The values in scientific format\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"small:  \" &lt;&lt; small &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"large:  \" &lt;&lt; large &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"whole:  \" &lt;&lt; whole &lt;&lt; std::endl &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; std::fixed; // Switch format mode to fixed\n\n  std::cout &lt;&lt; \"The same values in fixed format\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"small:  \" &lt;&lt; small &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"large:  \" &lt;&lt; large &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"whole:  \" &lt;&lt; whole &lt;&lt; std::endl &lt;&lt; std::endl;\n  \n  std::cout &lt;&lt; \"Now change the precision\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::setprecision(16); // More digits than double precision\n  std::cout &lt;&lt; \"small:  \" &lt;&lt; small &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::setprecision(0); // No decimal digits\n  std::cout &lt;&lt; \"large:  \" &lt;&lt; large &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::setprecision(2); // Set the width to flush to the right\n  std::cout &lt;&lt; \"whole:  \" &lt;&lt; std::setw(18) &lt;&lt; whole &lt;&lt; std::endl &lt;&lt; std::endl;\n  \n  return EXIT_SUCCESS;\n}\nThis program outputs\nSome values in (default) general format\nsmall:  3.14159\nlarge:  6.02e+17\nwhole:  2\n\nThe values in scientific format\nsmall:  3.141593e+00\nlarge:  6.020000e+17\nwhole:  2.000000e+00\n\nThe same values in fixed format\nsmall:  3.141593\nlarge:  602000000000000000.000000\nwhole:  2.000000\n\nNow change the precision\nsmall:  3.1415926535897931\nlarge:  602000000000000000\nwhole:                2.00",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#reading-input-from-the-console",
    "href": "intro_to_c++.html#reading-input-from-the-console",
    "title": "Basics of C++",
    "section": "Reading input from the console",
    "text": "Reading input from the console\nFor completeness we can read in data by using the std:cin object and the extraction operator &gt;&gt; as:\n#include &lt;iostream&gt;\n\nint main()\n{\n  int i; // Define a variable to store input\n  std::cout &lt;&lt; \"Please enter an integer value: \";\n  std::cin &gt;&gt; i; // Extract a value from the keyboard\n  std::cout &lt;&lt; \"The value you entered is \" &lt;&lt; i;\n  std::cout &lt;&lt; \" and its double is \" &lt;&lt; i*2 &lt;&lt; \".\" &lt;&lt; std::endl;\n  return EXIT_SUCCESS;\n}\nIn scientific calculations we rarely want direct interactions with the user since our code may be running remotely. Instead we can pass small bits of information via command line arguments which we will discuss in a later workshop.",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#logical-branching",
    "href": "intro_to_c++.html#logical-branching",
    "title": "Basics of C++",
    "section": "Logical branching",
    "text": "Logical branching\nTo make decisions that branch the execution in code we need conditional logical statements. One of the most common branching statements is IF ... THEN ... ELSE. In C/C++ if statements have the following general form:\n\nif ( logical expression \\(X\\) )\n{\n  **block of code** - executed only if X is TRUE\n}\nelse if ( logical expression \\(Y\\) )\n{\n  **block of code** - executed only if X is FALSE and Y is TRUE\n}\nelse\n{\n  **block of code** - executed only if X and Y are FALSE\n}\n\nAs we have seen already blocks of code are delimited by { ... }. If the blocks comprise of a single line then a more compact form can be used:\n\nif ( logical expression \\(X\\) ) line of code;\nelse if ( logical expression \\(Y\\) ) line of code;\nelse line of code;\n\nThe numerous logical operations available are best illustrated by a set of examples:\nx=5;              // Set some values for x and y\ny=0;\nif (x==y)         // x is not equal to y =&gt; FALSE\nif (y=x)          // sets y to x (non-zero) =&gt; TRUE\nif (!x)           // ! is the NOT operator =&gt; FALSE\nif (x||y)         // x OR y =&gt; TRUE\nif (x&&y)         // x AND y =&gt; FALSE\nif (x&&(y=x))     // x AND x =&gt; TRUE \nif (x=&gt;5 && y==x) // =&gt; FALSE\nif (x!=3 && y&lt;x)  // =&gt; TRUE\nA few points to note. In C/C++ = is for assignment of variables while == is for testing whether variables are EQUAL. The NOT operator is ! and NOT EQUAL is !=. Greater or equal is given by &gt;= and less or equal is given by &lt;=. Some logical operations are given by pairs of characters such as && for AND and || for OR. A logical expression involving numerical arithmetic is FALSE if it evaluates to zero, and TRUE otherwise3.\nUsing if statements we can now improve our earlier code accepting input from the user to include some basic error handling:\n#include &lt;iostream&gt;\n\nint main() {\n    int i; // Define a variable to store input \n    std::cout &lt;&lt; \"Please enter an integer value: \"; \n    // Extract a value from the keyboard\n    if (!(std::cin &gt;&gt; i)) {\n        std::cerr &lt;&lt; \"That wasn't an integer.\" &lt;&lt; std::endl; // Output to standard error\n        return EXIT_FAILURE; // Return error code\n    }\n    std::cout &lt;&lt; \"The value you entered is \" &lt;&lt; i;\n    std::cout &lt;&lt; \" and its double is \" &lt;&lt; i*2 &lt;&lt; \".\" &lt;&lt; std::endl;\n    return EXIT_SUCCESS;\n}",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#looping",
    "href": "intro_to_c++.html#looping",
    "title": "Basics of C++",
    "section": "Looping",
    "text": "Looping\nA common purpose of code is to repeating sequences of tasks. The most well known iterator is the FOR-LOOP which in C/C++ has the general form:\n\nfor ( initialiser ; test expression ; incrementer )\n{\n  **block of code**\n}\n\nThe bracketed section for ( ...) contains three pieces separated by semicolons. These are C/C++ commands which behave as follows:\n\ninitialiser – is executed once when then program first reaches the for statement.\ntest expression – is a logical expression which if TRUE allows the execution of the { ··· } code block.\nincrementer – is executed at the end of the code block, after which the test expression is re-evaluated to see if the code block is repeated.\n\nHere is a simple example:\n#include &lt;iostream&gt;\n\nint main() \n{\n  for (int i=0; i&lt;30; i=i+3) \n  {\n    std::cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \", i^2=\" &lt;&lt; i*i &lt;&lt; std::endl; // Display output\n  }\n  return EXIT_SUCCESS;\n}\nThis outputs:\ni=0, i^2=0\ni=3, i^2=9\ni=6, i^2=36\ni=9, i^2=81\ni=12, i^2=144\ni=15, i^2=225\ni=18, i^2=324\ni=21, i^2=441\ni=24, i^2=576\ni=27, i^2=729\nThere are also more specialised WHILE-LOOPS in C/C++ which come in two variants as:\n\ndo\n{\n**block of code**\n}\nwhile(\nlogical expression );\n\nand also as:\n\nwhile( logical expression )\n{\n  **block of code**\n}\n\nBoth forms repeatedly execute the code block until logical expression becomes FALSE. The difference between them is the do ... while form runs the code block and then evaluates condition, so the code block is guaranteed to be executed at least once, whereas the while form evaluates condition first. Here is a simple example:\n#include &lt;iostream&gt;\n\nint main() \n{\n  int i = 0; // Do initialiser\n  int isq; \n  \n  while (i&lt;10) \n  {\n    isq = i*i; // Compute i squared\n    std::cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \", i^2=\" &lt;&lt; isq &lt;&lt; \"\\n\"; // Display output\n    i++; // Do incrementer\n  }\n\n  return EXIT_SUCCESS;\n}\nThe output is now:\ni=0, i^2=0\ni=1, i^2=1\ni=2, i^2=4\ni=3, i^2=9\ni=4, i^2=16\ni=5, i^2=25\ni=6, i^2=36\ni=7, i^2=49\ni=8, i^2=64\ni=9, i^2=81",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#casting-and-variable-scope",
    "href": "intro_to_c++.html#casting-and-variable-scope",
    "title": "Basics of C++",
    "section": "Casting and variable scope",
    "text": "Casting and variable scope\nTo finish up let’s look at some subtle issues with variables. First, we stated earlier that C/C++ is strict about not having expressions that mix variables of different types. A commonly encountered case in scientific computing is expressions involving floating point and integer numbers. In fact C/C++ code mixing these numerical types will compile perfectly without error, but be careful to understand the implicit conversions occurring. Consider the following code:\n#include &lt;iostream&gt;\n\nint main() \n{\n  int i,j;\n  float x, y, z;\n  i=10;\n  j=3;\n  x=i/j; // Compute 10/3 and store in float x\n  std::cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; \"\\n\";\n  y = 2.71828; // Define float y\n  z = y/j; // Compute y/3 and store in float z\n  std::cout &lt;&lt; \"z=\" &lt;&lt; z &lt;&lt; \"\\n\";\n  return EXIT_SUCCESS;\n}\nThe output from this:\nx=3\nz=0.906093\nThe anomalous result of line 9 occurs because the compiler sees that i and j are both int so performs integer division throwing away the decimal remainder before it places the result into the floating point number x. In contrast the result of line 12 is correct since y is a floating point number and so the compiler up-converts the integer j to a float before computing the division. To recover the expected behaviour from line 9 we need to tell the compiler explicitly to perform this conversion in line 9 using a type cast. This amounts to replacing line x=i/j; with x=i/(float)j;, where (float) is the type cast. With this change the output is:\nx=3.33333\nz=0.906093\nVariables created in C/C++ have a well-defined scope. So far our codes have been very simple and we have declared variables at the start of the main() function that comprises our entire program. All subsequent lines within main() can access these variables. There are two cases where this is not true: (i) we don’t declare variables at the start, meaning they are only accessible to lines that come after, (ii) we declare variables inside a code block delimited by { ... }. This listing will generate compile errors and not run:\n#include &lt;iostream&gt;\n\nint main() \n{\n  std::cout &lt;&lt; num &lt;&lt; \"\\n\"; // Case (i) - variable num not declared yet!    \n  int num = 4;  \n  {\n    double pi = 3.14159; // Variable pi declared inside a block\n  }\n  std::cout &lt;&lt; pi &lt;&lt; \"\\n\"; // Case (ii) - outside the block where pi was declared\n  \n  return EXIT_SUCCESS;\n}\nThe first case is quite obvious, but the second is less so since the variable pi was defined before the output. Swapping lines 5-6, and deleting the { ... } on lines 7 and 9 allows the program to compile and run as expected. The purpose of restricting the scope of a variable within a code block is that it guarantees a variable cannot contaminate other parts of your code accidentally. A nice use of variable scope is inside a for loop:\n#include &lt;iostream&gt;\n\nint main () \n{\n  for (int i=0; i&lt;30; i=i+3) // Declare i inside for loop\n  {\n    int isq = i*i; // Declare and compute i squared\n    std::cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \", i^2=\" &lt;&lt; isq &lt;&lt; \"\\n\"; // Display output\n  }\n  return EXIT_SUCCESS;\n}\nHere we have dispensed with declaring the variable i for the iteration in the main() block and instead declare and initialise it within the for loop. Also, we declare and define isq within the for loop’s code block. Neither of these variables are accessible outside the for loop so we are free, for example, to declare and use i in another separate for loop later. When we introduce functions in an upcoming workshop we will consider the issue of variable scope again.",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#additional-information",
    "href": "intro_to_c++.html#additional-information",
    "title": "Basics of C++",
    "section": "Additional information",
    "text": "Additional information\nIf you need more detailed reference information then here are some useful websites:\n\nhttps://www.w3schools.com/cpp/default.asp\nhttps://www.tutorialspoint.com/cplusplus/index.htm\nhttps://www.cplusplus.com\n\nMany of these sites allow you to edit and run code online, for example via the C++ shell cpp.sh, but using Noteable as described above is strongly recommended.",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "intro_to_c++.html#footnotes",
    "href": "intro_to_c++.html#footnotes",
    "title": "Basics of C++",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThat said in C/C++ there are some implicit conversions or castings that occur which loosen this strictness, as we shall see shortly.↩︎\nHere we write out the namespace identify std:: everywhere. If this become a bit tedious you can add the line using std::cout; at the top of your main() function so you can simply write cout instead.↩︎\nBe careful testing equalities like x == 5 on floating point numbers. Even if this is TRUE, depending on the compiler and the system precision, it could be evaluated as FALSE because x might be represented internally as 5.0000000000001. In short, avoid directly testing equality with float or double variables.↩︎",
    "crumbs": [
      "<B>Week 8 |</B> <I>Intro to C++</I>",
      "Basics of C++"
    ]
  },
  {
    "objectID": "workshop4.html",
    "href": "workshop4.html",
    "title": "Workshop 4 - Functions",
    "section": "",
    "text": "The learning objectives of this workshop are:\n\nTo understand how to declare and implement functions.\nTo see how to overload functions and pass-by-reference arguments.\nTo be able to implement random number generation.\nTo understand how implement multi-file compilations.\n\n\n\n\n\n\n\nSummary lecture slides\n\n\n\nHere are the introductory lecture slides for this workshop.\n\n\n\n\n\n\n\n\nExample codes\n\n\n\nSource code for all the examples discussed in the notes for this workshop are available here as a .zip examples.\n\n\nStart this workshop by reading Functions. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>"
    ]
  },
  {
    "objectID": "using_hpc.html",
    "href": "using_hpc.html",
    "title": "Optional - Using HPC",
    "section": "",
    "text": "The C++ part of the course can be completed either using Noteable or using your own local development environment. However, you are encouraged to explore running C++ code on HPC resources available in Bristol. This optional guide will show you how to get started.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "using_hpc.html#joining-acrc-course-project",
    "href": "using_hpc.html#joining-acrc-course-project",
    "title": "Optional - Using HPC",
    "section": "Joining ACRC course project",
    "text": "Joining ACRC course project\nTo use the local HPC resources you have to join the course’s HPC project (code PHYS033164) with the ACRC via the form https://www.acrc.bris.ac.uk/login-area/apply.cgi. Getting your user created and associated to the project can take some time to be processed so be paitient. When you register you will see something like that shown in Figure 1.\n\n\n\n\n\n\nFigure 1: What to fill in to register for the HPC project on BP.\n\n\n\nAfter submitting this application the ACRC HPC team should email confirming they have granted you access to BluePebble (BP) and created a user with your UoB username and password.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "using_hpc.html#logging-on",
    "href": "using_hpc.html#logging-on",
    "title": "Optional - Using HPC",
    "section": "Logging on",
    "text": "Logging on\nYou can request access to BluePebble (BP) or BlueCrystal5 (BC5) cluster (ACRC will decide based on capacity). From a Linux or Mac computer simply use the built-in ssh client and connect to one of the main login nodes. Open a terminal window and type for BP:\nssh -X username@bp1-login.acrc.bris.ac.uk\nor for BC4:\nssh -X username@bc4login.acrc.bris.ac.uk\nIn either case remember to replace the username part with your UoB username. It will prompt you for a password. Type this in (your typed text is not displayed) and hit [enter]. Something like this will be outputted (for BP):\nssh -X username@bp1-login.acrc.bris.ac.uk\nusername@bp1-login.acrc.bris.ac.uk's password:\nWarning: untrusted X11 forwarding setup failed: xauth key data not generated\n*** This system is available to authorised users only ***\n\n[username@bp1-login01 ]$ \nOn Windows you will need to download an ssh client such as Putty, shown in Figure 2, or bitvise ssh and setup a connection to the cluster similar to above.\n\n\n\n\n\n\nFigure 2: The ssh client Putty popular on Windows. To login to BP the Host Name is bp1-login.acrc.bris.ac.uk while for BC4 it is bc4login.acrc.bris.ac.uk and ensure that the ssh protocol is used.\n\n\n\nTo connect to the cluster create a session using:\nbp1-login.acrc.bris.ac.uk\nor \nbc4login.acrc.bris.ac.uk\nssh\n22 (leave as default)\nHit “Open” to connect! A terminal windows should appear similar to that described above for Linux and Mac machines where you will enter your UoB credentials.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "using_hpc.html#transferring-files",
    "href": "using_hpc.html#transferring-files",
    "title": "Optional - Using HPC",
    "section": "Transferring files",
    "text": "Transferring files\nIn addition to an ssh terminal it is essential to have a secure file transfer sftp client open and logged in. A good choice FileZilla which fool-proof and reliable cross-platform client for downloading and uploading files to and from a remote computer.\n\n\n\n\n\n\nFigure 3: The sftp client FileZilla can be used on Windows, Mac or Linux machines. Use the Quickconnect feature to login to cluster.\n\n\n\nDownload and install on your computer the FileZilla client from https://filezilla-project.org. Once opened the program will display a familiar split-view file browser window with the left hand side of the screen showing your local files, as shown in Figure 3. When you connect to the cluster, your cluster files will appear on the right hand side.\nTo connect to the cluster, we’ll just need to enter our credentials in the top bar of the application:\nsftp://bp1-login.acrc.bris.ac.uk\nor \nsftp://bc4login.acrc.bris.ac.uk\nYour UoB password\n22\nHit “Quickconnect” to connect! You should see your remote files appear on the right hand side of the screen. You can drag-and-drop files between the left (local) and right (remote) sides of the screen to transfer files.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "using_hpc.html#compiling",
    "href": "using_hpc.html#compiling",
    "title": "Optional - Using HPC",
    "section": "Compiling C++ Code",
    "text": "Compiling C++ Code\nYou can run the Mandelbrot set calculation on a HPC cluster (either BluePebble or BlueCrystal5). Here we will use this code as an interesting example for you to try out compiling and submitting jobs to the cluster.\n\n\n\n\n\n\nFigure 4: The division of the \\(3 \\times 3\\) square of the complex plane into N\\(^2=16\\) boxes.\n\n\n\nDownload mandelbrot.cpp and transfer it to the cluster. Using the terminal logged into the cluster navigate to the directory you put this code in. We now compile it by first loading the GNU C-compiler module and then running the compiler as:\nmodule add gcc/12.3.0\ng++ -std=c++17 mandelbrot.cpp -o mandelbrot\nThis command should run without any output or errors if your terminal is currently located at the same directory you put the code. There are two useful features of this code that will facilitate its simple parallelization across several nodes of a HPC resource:\n\nIt accepts four command line arguments of the form mandelbrot N P D n. Here N is the partitioning of the \\(3 \\times 3\\) square of the complex plane into N \\(\\times\\) Nboxes, as shown in Figure 4. The parameter P then specifies that each box is to be divide into P \\(\\times\\) P points. Thus we are sampling the \\(3 \\times 3\\) square of the complex plane with NP \\(\\times\\) NP points in total. Each point is computed to a maximum of D iteration depth. Finally, the parameter n specifies which of the \\(1,2,\\dots,\\) N\\(^2\\) boxes this particular instances of the code is to compute.\nThe data computed by the code is saved in a comma-separated-value (.csv) text file. The data is formatted so each row stores \\(c_x, c_y, n(c)\\) with the filename fractal_data_n.csv for box n.\n\nYou will exploit these features to break up and distribute this calculation across the cluster shortly.\nWe can test that the Mandelbrot code runs by typing (don’t forget the ./):\n./mandelbrot 1 20 20 1\nMandelbrot set computation complete\nwhich specifies that it uses just 1 box with a \\(20\\times 20\\) grid, an iteration depth of 20 and computes the points inside box 1 (the only box in this case). We use such light computational parameters because this command runs our code on the front-end login node of the cluster. Only ever do this for extremely simple/short test runs of your code.\n\n\n\n\n\n\nImportant\n\n\n\nNever run code that requires substantial computational effort lasting more than 1 second on the front-end login node!\n\n\nWhen the code finishes you will find a file fractal_data_1.csv has appeared in your directory. You can examine its contents using the more command as\nmore fractal_data_1.csv\n-2,-1.5,1\n-2,-1.34211,1\n-2,-1.18421,1\n-2,-1.02632,1\n-2,-0.868421,1\n-2,-0.710526,1\n-2,-0.552632,1\n-2,-0.394737,1\n-2,-0.236842,1\n-2,-0.0789474,1\n-2,0.0789474,1\n-2,0.236842,1\n-2,0.394737,1\n-2,0.552632,1\n-2,0.710526,1\n-2,0.868421,1\n-2,1.02632,1\n-2,1.18421,1\n-2,1.34211,1\n-2,1.5,1\n-1.84211,-1.5,1\n-1.84211,-1.34211,1\n-1.84211,-1.18421,1\nfractal_data_1.csv\nAs promised the data is saved in the format where each row stores \\(c_x, c_y, n(c)\\) with the filename fractal_data_n.csv for box n. To fully exploit this ability to divide up the computation into subtasks (boxes) that can each be calculated independently requires that we submit jobs to the scheduler on the cluster.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "using_hpc.html#job-scheduling-on-a-cluster",
    "href": "using_hpc.html#job-scheduling-on-a-cluster",
    "title": "Optional - Using HPC",
    "section": "Job scheduling on a cluster",
    "text": "Job scheduling on a cluster\nAll HPC clusters use a queueing system, or a scheduler, to organise the order in which user jobs are run. The ACRC systems all use a scheduler called SLURM. Its key features are:\n\nIt matches the available computing resources to those required to run a particular job.\nIt enforces a strict “fair-share\" policy, where all users are given equal access to the compute resources. No monopolisation is possible.\nIt balances the work load across all the nodes of the cluster.\nIt maintains a queue of jobs to be run on the cluster. Jobs are typically submitted in batch mode, meaning that no human intervention is required when it is time to run the job.\n\nDepending on the available resources, your job may run immediately or only after some time. This is to be expected since you are not the only one using the system and there is a queue. Remember also that the front-end login nodes are intended only for basic tasks such as uploading data, managing files, compiling software, editing scripts, and checking on or managing your jobs. Small-scale interactive work may also be acceptable if your resource requirements are minimal. Otherwise, all jobs must be submitted to the queue.\nWe can obtain a summary of the queues (or partitions) available on the cluster using the sinfo command (only some of the output shown, more queues will displayed):\nsinfo -s\nPARTITION  AVAIL  TIMELIMIT   NODES(A/I/O/T) NODELIST\ntest          up    1:00:00      143/3/6/152 bp1-compute[001-009,015-017,019-020,031-040,049-072,081-104,121-168,171-184,190-198,211-219]\nshort         up 3-00:00:00      139/0/4/143 bp1-compute[015-017,019-020,031-040,049-072,081-104,121-168,171-184,190-198,211-219]\ncompute*      up 14-00:00:0      135/0/5/140 bp1-compute[020,031-040,049-072,081-104,121-168,171-184,190-198,211-219,231]\ngpu           up 14-00:00:0        15/3/0/18 bp1-gpu[002-003,007-008,013-015,019-020,024-027,030,035-037,040]\ngpu_short     up    6:00:00        11/4/0/15 bp1-gpu[001-003,007-008,013-015,019-020,024-027,030] \nThe first column is the list of the partitions summarised in Tbl. 1. The asterisk next to compute tells us that this is the default partition that will be used if you don’t specify one. The availability column should tell us that all partitions can be used. The time limit shows the maximum time that a job running in that partition is allowed to run for. It will usually be in days-hours:minutes:seconds format. The nodes column tells you how many nodes are in the various states. Allocated (A) are nodes that are currently running jobs, idle (I) are currently not running anything but are available to do so, other (O) are likely in some sort of maintenance mode and total (T) is the total number of nodes in that partition. Finally the node list tells you the names of all the nodes which are part of that partition. As we shall see shortly you can specify the partition your job runs in in the job script. You can find a huge amount of information about the ACRC clusters on its online documentation pages https://www.acrc.bris.ac.uk/protected/hpc-docs/introduction/index.html (this will require a UoB login).\n\n\nAn overview of some partitions on BP or BC4.\n\n\nPartition\nPurpose\n\n\n\n\ncompute\nGeneral purpose queue for jobs on standard nodes\n\n\ngpu\nRestricted to the limited number of GPU nodes\n\n\ngpu_veryshort\nA very restricted run-time queue for testing GPU jobs\n\n\nshort and test\nA mix of resources with a restricted run-time\n\n\nteach_cpu\nDedicated nodes for running code in teaching",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "using_hpc.html#submitting-jobs",
    "href": "using_hpc.html#submitting-jobs",
    "title": "Optional - Using HPC",
    "section": "Submitting jobs",
    "text": "Submitting jobs\nTo submit jobs we have to first wrap up the code to run in a bash script. This script will contain so-called #SBATCH flags that set tell SLURM what kind of job you want it to run in terms of its resource allocation. An example is contained in the file run_mandelbrot.sh which you uploaded to the directory wkshp1 earlier and is also listed here:\n#!/bin/bash\n\n#SBATCH --account=PHYS031304\n#SBATCH --job-name=fractal\n#SBATCH --partition=teach_cpu\n#SBATCH --nodes=1\n#SBATCH --ntasks-per-node=1\n#SBATCH --time=0:0:10\n#SBATCH --mem=100M\n\necho 'Compute my first fractal'\nhostname\n./mandelbrot 1 20 20 1\nThe #SBATCH start by setting the job name to something meaningful to us. Then they select the teach_cpu partition since we’re just running a small test job as a part of a teaching course. Next we tell SLURM about the shape of our job. In this case we are just going to run 1 process (task) on 1 node. It’s only a very small short job so we choose a run time of 10 seconds and a memory usage of 100M. The three last lines are standard shell script commands. The first prints some text, the second prints the hostname of the node on the cluster that the script is executed on, and the last runs the Mandelbrot set calculation identically to what we did above on the front-end but now on a cluster compute node.\nTo submit this job to the scheduler simply use the sbatch command\nsbatch run_mandelbrot.sh\nSubmitted batch job 3955481\nThe line it prints tells you the ID number of the job. Make a note of this as this is how you can refer to the job. This job should run very quickly, but more demanding ones may take longer. You can check the status of your waiting jobs by using\nsqueue --state=PENDING\nand you can kill any running or pending job using\nscancel &lt;jobid&gt;\nwhere &lt;jobid&gt; should be replaced with the ID of the job you want to cancel. To keep track of how our job is progressing we can use\nsacct -j 3955481\n     JobID    JobName  Partition    Account  AllocCPUS      State ExitCode\n------------ ---------- ---------- ---------- ---------- ---------- --------\n3955481       test_job  teach_cpu    default          1  COMPLETED      0:0\n3955481.bat+  batch                  default          1  COMPLETED      0:0\nThe first (the one that just starts with 3955481 in the example) is the summary for the overall job, and it tells us that it has been completed already. By default SLURM will put the output in a file called slurm-&lt;jobid&gt;.out so we’ll find it in slurm-3955481.out:\nmore slurm-3955481.out\nCompute my first fractal\ncompute130.BP.acrc.priv\nMandelbrot set computation complete\nThis is the output that would ordinarily be displayed in the terminal by the commands included in the script run_mandelbrot.sh.",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "using_hpc.html#running-array-jobs",
    "href": "using_hpc.html#running-array-jobs",
    "title": "Optional - Using HPC",
    "section": "Running array jobs",
    "text": "Running array jobs\nGiven our Mandelbrot code can divide the full job into lots of boxes and run one box each it is ideally suited for submitting what are called array jobs. This is simply where the scheduler will submit many jobs at once passing an index to each job. We need a slightly modified bash script for this contained in array_mandelbrot.sh listed here:\n#!/bin/bash\n\n#SBATCH --account=PHYS033164\n#SBATCH --job-name=fractal_array\n#SBATCH --partition=teach_cpu\n#SBATCH --nodes=1\n#SBATCH --ntasks-per-node=1\n#SBATCH --time=0:0:10\n#SBATCH --mem=100M\n#SBATCH --output=./output/slurm-%A_%a.out\n#SBATCH --array=1-16\n\necho 'Fractal array job -' ${SLURM_ARRAY_TASK_ID}\nhostname\n./mandelbrot 4 200 200 ${SLURM_ARRAY_TASK_ID}\nmv ./fractal_data_${SLURM_ARRAY_TASK_ID}.csv ./data\nHere we have made some modifications compared to our earlier submission script. First we have told SLURM to put its output files in the output directory to avoid them clogging up your wkshp1 directory. Crucially we have added another #SBATCH flag –array=1-16 telling the scheduler to run jobs numbered from \\(1,2,\\dots,16\\). This total number of jobs is consistent with N\\(^2=16\\) boxes used by mandelbrot. The job index is stored in the variable SLURM_ARRAY_TASK_ID which is then printed out and passed to the mandelbrot code so it knows which box to run. Finally we have added a mv command line instruction to tidy up at the end by moving the data file from this calculation into the data directory.\nIn preparation for submitting this array job create the directories data and output mentioned above in your wkshp1 directory that we are working in. We then submit this array job using sbatch exactly as we did before:\nsbatch array_mandelbrot.sh\nSubmitted batch job 5096536\nWe still only get one job ID for this submission. But if we now examine how this job is progressing we get:\nsacct -j 5096536\n       JobID    JobName  Partition    Account  AllocCPUS      State ExitCode \n------------ ---------- ---------- ---------- ---------- ---------- -------- \n5096536_16   fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_16.+      batch               default          1  COMPLETED      0:0 \n5096536_1    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_1.b+      batch               default          1  COMPLETED      0:0 \n5096536_2    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_2.b+      batch               default          1  COMPLETED      0:0 \n5096536_3    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_3.b+      batch               default          1  COMPLETED      0:0 \n5096536_4    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_4.b+      batch               default          1  COMPLETED      0:0 \n5096536_5    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_5.b+      batch               default          1  COMPLETED      0:0 \n5096536_6    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_6.b+      batch               default          1  COMPLETED      0:0 \n5096536_7    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_7.b+      batch               default          1  COMPLETED      0:0 \n5096536_8    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_8.b+      batch               default          1  COMPLETED      0:0 \n5096536_9    fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_9.b+      batch               default          1  COMPLETED      0:0 \n5096536_10   fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_10.+      batch               default          1  COMPLETED      0:0 \n5096536_11   fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_11.+      batch               default          1  COMPLETED      0:0 \n5096536_12   fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_12.+      batch               default          1  COMPLETED      0:0 \n5096536_13   fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_13.+      batch               default          1  COMPLETED      0:0 \n5096536_14   fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_14.+      batch               default          1  COMPLETED      0:0 \n5096536_15   fractal_a+   teach_cpu   default          1  COMPLETED      0:0 \n5096536_15.+      batch               default          1  COMPLETED      0:0\nlisting that all 16 jobs have been completed. We will now find that SLURM has placed the output in 16 files called slurm-&lt;jobid&gt;_&lt;arrayid&gt;.out which are in the output directory. Crucially we will also have 16 data files fractal_data_&lt;n&gt;.csv now contained in the data directory. For the parameters chosen in our submission script array_mandelbrot.sh we have successfully divided our \\(800 \\times 800\\) grid calculation into 16 subtasks and distributed their execution over many different nodes on the cluster. Well done!\n\n\n\n\n\n\nOptional Task: Big calculation using HPC\n\n\n\nCopy across into same directory the source files mandelbrot.cpp and also the two scripts run_mandelbrot.sh and array_mandelbrot.sh found in the hpc_scripts subdirectory of the starter files. Compile mandelbrot.cpp as described above.\nEdit on cluster (or on your computer and copy it back across) the relevant line in the bash script wrapper run_mandelbrot.sh to specify a more demanding calculation than the \\(20\\times 20\\) grid above and submit this a job to the cluster’s scheduler. Confirm it was completed successfully and examine the output.\nNow modify the array_mandelbrot.sh submission script to specify an even more ambitious high resolution and deep calculation of the Mandelbrot set. For example you could use N \\(=10\\), P \\(=1000\\), D \\(=2000\\). Submit this array job and confirm all \\({\\tt N}^2\\) jobs have been successfully executed.\nDownload from cluster all the resulting data files on to your own computer. Now write a Python script to post-process these files combining computed the points from all the boxes and generate an image similar to that shown in Fig. 1 in Simple C++ calculation, but with a higher resolution and clarity.\n\n\n\n\n\n\n\n\nHint\n\n\n\nYou may find the csv Python package useful and be sure to construct the image from the box data using the ordering given by lines 71-72 of mandelbrot.cpp that is listed in Simple C++ calculation.\n\n\n\\(\\Box\\)",
    "crumbs": [
      "<B>Week 7 |</B> <I>The shell and C++</I>",
      "*Optional* - Using HPC"
    ]
  },
  {
    "objectID": "useful_extras.html",
    "href": "useful_extras.html",
    "title": "Useful extras",
    "section": "",
    "text": "This background information document discusses some very useful miscellaneous topics in C/C++. In particular these extra will make sure you have all you need to understand the code from the first workshop mandelbrot.cpp.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "useful_extras.html#basic-string-manipulation",
    "href": "useful_extras.html#basic-string-manipulation",
    "title": "Useful extras",
    "section": "Basic string manipulation",
    "text": "Basic string manipulation\nIn this course we have not said much about strings mainly because our interest is focused more on numerical calculations. Here we shall consider just some basics needed for a common task in scientific computing, namely generating filenames for save files which include numerical parameters embedded in them. At a basic level in C a string is just an array of character type variables. In C++ this is elevated to a string object which makes life a bit easier, which we can access once we add #include &lt;string&gt; to our headers at the top of our source code. Here is the snippet of code from mandelbrot.cpp which appends an integer n corresponding to the box number to a file name prefix string:\nstd::string filename = \"fractal_data_\"; // Fixed filename prefix.\nfilename += std::to_string(n); // Append the box number to the data file.\nfilename += \".csv\"; // Save as a comma separated value text file.\nHere in line 1 we declare a string object and initialise it with some fixed string data. We can then concatenate other bits of string data to this string using the += operation on this object, as in line 3. To concatenate a string conversion of a numerical variable we access the to_string() method of the string object, as in line 2.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "useful_extras.html#command-line-argument",
    "href": "useful_extras.html#command-line-argument",
    "title": "Useful extras",
    "section": "Command-line argument",
    "text": "Command-line argument\nIn scientific computing we tend to write standalone applications that run in the terminal. For this reason a very common way to communicate a small number of parameters and other useful information to our program is to pass them as command line arguments. In C/C++ this is accomplished using a set of fixed arguments for the main() function. The following example illustrates how this works:\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// This program \"cmdtest\" is expecting 4 input arguments:\n// cmdtest N m L name\n// N = int, m dbl, L int, name string \nint main(int argc, char** argv)\n{\n    // Checking if number of argument is equal to 4 or not.\n    if (argc != 5) \n    {\n        std::cout &lt;&lt; \"ERROR: need 4 input arguments - cmdtest N m L name\" &lt;&lt; std::endl;\n        return EXIT_FAILURE;\n    }\n  \n    // Convert command line inputs from strings to integers:\n    int N = atoi(argv[1]); \n    double m = atof(argv[2]);\n    int L = atoi(argv[3]);\n    std::string name = argv[4];\n    \n    std::cout &lt;&lt; \"N = \" &lt;&lt; N &lt;&lt; \" m = \" &lt;&lt; m &lt;&lt; \" L = \" &lt;&lt; L &lt;&lt; \" name = \" &lt;&lt; name &lt;&lt; std::endl;\n    return EXIT_SUCCESS;\n}     \nAssuming we saved this code as cmdtest.cpp then we compile and run it as:\ng++ cmdtest.cpp -o cmdtest\n./cmdtest 30 3.14159 13 test_file\nN = 30 m = 3.14159 L = 13 name = test_file\nLet’s unpack how this works. The main() function has two input arguments int argc and char** argv. The first argc is the counter for the number of space-separated items the user wrote in the terminal when executing the program. In the case above argc = 5, because it includes cmdtest as well. In lines 10-14 we test to ensure that we have exactly 5 items corresponding to 4 input arguments, and exit if this is not true. If we provided enough arguments then we proceed to declare and populate appropriate variables in our program with those inputs. The second argument argv is defined to be char**, that is it is a pointer to a pointer to a character. What this means is that argv is an array of character arrays (e.g. strings), so if we access elements of this array as say argv[1] we get the second array of characters passed by the operating system from the terminal corresponding to our first command line argument. This is supposed to be an integer input so we perform a conversion of a string to integer using the atoi() function on line 17. To convert to a double we use atof() function instead, like in line 18. If the input is supposed to be string then no conversion is needed as in line 20.\nCommand line arguments are a very convenient and quick way to pass information to our code. However, if we need more data than a handful of numbers and strings then we should instead use an input data file, and just pass its filename to our program instead.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "useful_extras.html#reading-and-writing-to-a-file",
    "href": "useful_extras.html#reading-and-writing-to-a-file",
    "title": "Useful extras",
    "section": "Reading and writing to a file",
    "text": "Reading and writing to a file\nA couple of times now you have been given code which writes to a file for you. Here we should explain this more explicitly since we will often want to save the results of our calculations by writing text output to an external file. This is essentially identical to writing to the console screen except that insertions are performed instead on IO stream object initialised as a file. To do this we now need to include the fstream.hpp header as illustrated by the following listing:\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nint main() \n{\n  double pi = 3.141592;\n  std::ofstream myfile; // Declare a file stream object\n  myfile.open (\"example.txt\"); // Open file\n  if (myfile.is_open()) // Query myfile object to see if it was successful\n  {\n    myfile &lt;&lt; \"The value of pi = \" &lt;&lt; pi &lt;&lt; \"\\n\"; // Insert data to this file\n    myfile.close(); // Close the file\n    std::cout &lt;&lt; \"File example.txt was successfully opened and written to.\\n\"; // Display an success message\n    return EXIT_SUCCESS; // Return successful execution value\n  }\n  else {\n    std::cout &lt;&lt; \"File example.txt failed to open.\\n\"; // Display an error message\n    return EXIT_FAILURE; // Return error value\n  }\n}\nIf successfully executed1 this program will create a file example.txt containing a single line:\nThe value of pi = 3.121592\nAll the formatting described in Intro to C++ for outputting to the console can be identically applied to outputs to a file.\nFor completeness we should also briefly describe how to read in data from a text file. We will consider the simplest case of an input text file containing one number per line2 Suppose we have a file input.txt containing:\n3.14159\n2.71828\n1.01000\nThe following program will read this data:\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    std::string line; // Declare a string used to store each line\n    double number; // Double to store number\n\n    // Declare and initialise an input file stream object\n    std::ifstream data_file(\"input.txt\"); \n\n    while (getline(data_file, line)) // Read the file line by line\n    {\n        number = std::stod(line); // Convert line into a number\n        std::cout &lt;&lt; number &lt;&lt; std::endl; // Output number to console\n    }\n\n    // Close the file\n    data_file.close();\n    return EXIT_SUCCESS;\n}    \nThe key points here are line 11 where the input file stream is declared and initialised, in this case to read a file input.txt. We then use the getline() function in line 13 which reads the input file one line at a time and puts the contents into the string line. We don’t know how long the file is so we use a while loop that exits when the end of the file is reached since getline() returns FALSE. On line 15 we use the function std::stod() which converts a string object into a double. The output from the above program is:\n3.14159\n2.71828\n1.01\nwhich shows our conversion has worked since the trailing 0’s for the last number are not displayed for a numerical value, while they would be if we simply printed the string read in.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "useful_extras.html#random-number-generation",
    "href": "useful_extras.html#random-number-generation",
    "title": "Useful extras",
    "section": "Random number generation",
    "text": "Random number generation\nScientific methods such as Monte Carlo sampling often need random numbers. The following program illustrates how we can obtain random numbers in C++:\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;chrono&gt;\n\nint main()\n{\n    static const int N = 10; // Some fixed number of random numbers needed\n    double nums[N]; // Define an array to store the numbers\n    double avg = 0.0; // Will store the average of the numbers generated\n\n    // Initialise the random number generator:\n    std::default_random_engine generator;\n    std::uniform_real_distribution&lt;double&gt; distribution(-1.0,1.0);\n    \n    // Initialise a clock object\n    typedef std::chrono::high_resolution_clock myclock;\n    myclock::time_point beginning = myclock::now();\n\n     // Obtain a seed from the timer and apply it\n    myclock::duration d = myclock::now() - beginning;\n    unsigned seed = d.count();\n    generator.seed(seed); // Apply the seed\n\n    for(int i = 0; i &lt; N; i++)\n    {\n        nums[i] = distribution(generator); // Request a random number\n        avg += nums[i];   \n        std::cout &lt;&lt; \"nums[\" &lt;&lt; i &lt;&lt; \"]  = \" &lt;&lt; nums[i] &lt;&lt; \"\\n\";\n    }\n    avg /= N;\n    std::cout &lt;&lt; \"avg = \" &lt;&lt; avg &lt;&lt; \"\\n\";\n    \n    return EXIT_SUCCESS;\n}    \nThis program has a lot of mysterious looking C++ OOP lines in it. These will be explained in more detail next year, but for now we don’t need to fully understand the notation of these lines to just use them. Notice that we include the header &lt;random&gt;, so we can access the pseudo-random number generator in the standard library. We initialise the generator on lines 12-13 to be a uniform real distribution between -1 and 1. We also include the header &lt;chrono&gt;, so we can measure elapsed times. We initialise the clock on lines 16-17. We then use the elapsed time to create a unique seed for the generator on lines 20-22. We are now ready to start extracting random numbers from the generator, so these lines can be used as a template. In the program above this is done on line 26. After this the number is displayed and sum is computed so the average of all the numbers generated can be displayed at the end.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "useful_extras.html#multi-file-compilation",
    "href": "useful_extras.html#multi-file-compilation",
    "title": "Useful extras",
    "section": "Multi-file compilation",
    "text": "Multi-file compilation\nWe saw last week that we often have to declare a function declaration at the top of our source code to ensure the compiler knows what it does before any calls to it. We are then free to write the definition/implementation of the function where ever we want in our source code file. We take this freedom further by separating the declarations and definitions of functions into different files. Conventionally we put all the declarations in a header file usually with a .h or .hpp extension. We put all the code defining those functions in sources files with a .cpp extension just like our main source code file.\nLet’s modify the simple example from last week for the sum() function. Instead of one file we now create three files, sum.hpp, sum.cpp and main.cpp. We put the following code into these files:\n/* --- sum.hpp --- */\n#ifndef _SUM_H // Header guard\n#define _SUM_H\n\ndouble sum(double a, double b); // Function to return the sum of the two doubles\n\n#endif   \nfollowed by\n/* --- sum.cpp --- */\n#include \"sum.hpp\" // Our new header\n\ndouble sum(double a, double b)\n{\n    return a + b;\n}  \nand finally\n/* --- main.cpp --- */\n#include &lt;iostream&gt; // Usual library header\n#include \"sum.hpp\" // Our new header\n\nint main()\n{\n    std::cout &lt;&lt; sum(10,20) &lt;&lt; std::endl;\n    return EXIT_SUCCESS;\n}\nThere are several ways we can compile this set of files. The long-way is to combine each .cpp file into an object file first, then link them altogether at the end:\ng++ main.cpp -o main.o\ng++ sum.cpp -o sum.o\ng++ main.o sum.o -o sum_example\n./sum_example\nTypically we would put all these lines into a shell script. Breaking up the compilation can be helpful for large projects where, for example, you have only modified one or two source files, so you need only rerun the compilation of those files into object files. In the example above it is sufficiently simple that one compilation line suffices:\ng++ main.cpp sum.cpp -o sum_example\n./sum_example\nwhere we supply all of the .cpp files required. In both cases we did not need to include the .hpp file. This is because the preprocessor command #include \"sum.hpp\" in the two .cpp files copies and pastes the contents of sum.hpp into both of these files already. We named the final executable sum_example.\nSo what’s the point of this multi-file approach? The example above shows how it works but is far too simple to fully illustrate why is it desirable. For large projects with many 100’s or 1000’s of lines of code this approach is essential. Header files are useful because they allow you to collect all function declarations together, and then #include them into your source files without having to continually type them out again and again. This reduces typing and errors. Using separate .cpp files is useful because we can put the implementation of related functions into their own file, rather than having lots of functions in one file. This allows us to logically structure the code of our projects.\nOne problem with header files is that they should only be included once in a source file. Without care this is difficult to guarantee in practice for large projects. So we use “header guards” to check if a header file has been included more than once, and to then stop the second (or subsequent) includes. The “header guards” are the lines #ifndef _SUM_H, #define _SUM_H and #endif that appear in sum.hpp. These are preprocessor commands. The first time sum.hpp is included using #include \"sum.hpp\" in any file, the line #ifndef _SUM_H, meaning “if not defined then”, evaluates to true, and so all of the code between that line and #endif is copied and pasted into the source file. The first of these lines is #define _SUM_H, which sets the preprocessor variable3 _SUM_H equal to 1. This means that the second time sum.hpp is included, the #ifndef _SUM_H evaluates to false (as _SUM_H is now defined), and so none of the lines between here and #endif are copied and pasted. This is an inelegant way of solving the multi-include problem, and is a legacy of C++ being developed from C.",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "useful_extras.html#dynamically-linking-libraries",
    "href": "useful_extras.html#dynamically-linking-libraries",
    "title": "Useful extras",
    "section": "Dynamically linking libraries",
    "text": "Dynamically linking libraries\nIn this week’s seminar we used an example where we compiled the C/C++ source file integrate.cpp as a shared library as:\ng++ -shared integrate.so -o integrate.cpp\nHow does this differ from the broken up compilation example above? Normally we compile a source file into an object file and then we link at compile time all the object files to create our standalone executable. This linking is said to static so all the machine code in the object is embedded directly inside the executable. Once complete the executable no longer need the object file and it can be deleted. In the case above we have not compiled integrate.cpp into an object file .o, but instead into a shared object file .so. When we compile our executable using this shared object file as\ng++ --std=c++11 integrate.so compute_integral.cpp -o compute_integral\nThis creates an executable compute_integral, but the machine code inside integrate.so is not embedded into it. Rather it remains in integrate.so and is dynamically linked at run-time into the executable. The file integrate.so needs to be present for the executable to run. In effect we have created a shared dynamically linking library with an associated header integrate.hpp. This is how most libraries in C/C++ are organised, typically with names of the form lib&lt;name&gt;.so, such as the standard library libstdc++.so4 we have used frequently. Dynamically linked libraries makes executable files smaller, and if many executables use the same library often, like standard library call to print to the console, only one copy of this machine code is ever loaded into the memory and is used by all programs. Befofe you can run compute_integral you may need to adjust the LD_LIBRARY_PATH of your terminal. This is a system path which tells the operating system which directories to search for shared libraries. We can add the current directory as\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./\nand then ./compute_integral should work. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "useful_extras.html#footnotes",
    "href": "useful_extras.html#footnotes",
    "title": "Useful extras",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe listing included here checks the return value of myfile.open to ensure our desired file was opened without errors.↩︎\nThis can be generalised to process comma separated value data, like we often outputted, but requires additional lines to parse the delimiters “,\" on each line.↩︎\nWe give the variable a funky looking capitalised name starting with an underscore to make it very clear it is a preprocessor variable.↩︎\nStandard libraries are a part of the compiler package so we don’t have to specify them explicitly in the compilation command like we did for integrate.so.↩︎",
    "crumbs": [
      "<B>Week 10 |</B> <I>Functions and extras</I>",
      "Useful extras"
    ]
  },
  {
    "objectID": "structures_objects.html",
    "href": "structures_objects.html",
    "title": "Structures and Objects",
    "section": "",
    "text": "This background information document will introduce the idea of a structure in C/C++ before briefly outlining the idea of object classes in C++.",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Structures and Objects"
    ]
  },
  {
    "objectID": "structures_objects.html#structures",
    "href": "structures_objects.html#structures",
    "title": "Structures and Objects",
    "section": "Structures",
    "text": "Structures\nWe saw a couple of weeks back that C++ vectors are great at bundling together related variables in dynamically sized arrays, but they were limited because each member had to be the same data type. Also, even if all our data of the same type organising it into a single array may not make sense conceptually. For example, imagine you are writing a program to solve Newton’s equations for the sun, earth and moon. You might proceed by defining all the quantities of interest separately:\ndouble sunPos[3], moonPos[3], earthPos[3]; // Position vectors\ndouble sunVel[3], moonVel[3], earthVel[3]; // Velocity vectors\ndouble sunMass, earthMass, moonMass; // Masses\nLogically our problem comprises three bodies so our code would be much more elegant and readable if we collected the variables together in a way that mimicked this. Defining a single array for each body like this:\ndouble sun[7], moon[7], earth[7]; // Position vector + velocity vector + mass.\ndoes collect all the information together and is cleaner, but it is also very obtuse1. A better way is to use a structure. If a variable is a box, then you can think of a structure as a bigger box, with smaller boxes inside it. This is best illustrated by defining a structure for the information about a planetary body as:\nstruct body {\n    double mass; // Mass\n    double pos[3]; // Position vector\n    double vel[3]; // Velocity vector\n};\nHere the struct &lt;name&gt; indicates you are creating a structure called &lt;name&gt; and then between { ... }; is a one-by-one declaration of the member variables of this structure. By declaring a structure we are effectively defining a new data type (called an abstract data type) which we can use in our code just like a primitive data type, e.g. int or double. In our code we can instantiate three Body structures for our problem as:\nbody sun, moon, earth; // Declare structures for all three bodies\nanalogous to how we would define three variables with a primitive data type:\nint myVar1, myVar2, myVar3; // Declare structures for all three bodies\nStructure are declared outside and before the main() function at the top of a source file. We don’t access members of a structure using an index, rather we use a field name with dot ., for example sun.Mass gives us access to the mass of the sun. Note that names of members of structures (mass, pos,vel) are the same for every structure of the body type, but the name of the structure is different for each instance, sun, earth and moon. Putting this together our program using the Body structure might begin like this:\n#include &lt;iostream&gt;\n\n// Define the structure outside and before the main() function\nstruct body {\n    double mass; // Mass\n    double pos[3]; // Position vector\n    double vel[3]; // Velocity vector\n};\n\nint main() \n{\n    Body sun, moon, earth; // Declare structures for all three bodies\n  \n    earth.mass = 6.0e24; // Mass of earth [kg]\n    // Set the sun as the origin of our coordinate system:\n    sun.pos[0] = 0.0;\n    sun.pos[1] = 0.0;\n    sun.pos[2] = 0.0;\n\n    // and so on ...\n\n    return EXIT_SUCCESS;\n}\nLike any data type we can define an array of structures with the usual notation:\nbody neptune_moons[14]; // Declare an array of 14 body structures\nWe access the elements of a given structure in this array using an index as usual, e.g. neptune_moons[3].mass to access the 4th moon’s mass, and similarly elements of an array inside a structure such as neptune_moons[2].pos[0] to access the 3rd moon’s \\(x\\) position coordinate.\nNaturally we can pass structures as arguments to functions. Consider the following program using a slightly modified version of our structure body:\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing std::cout, std::endl;\n\nstruct body {\n    double mass; // Mass\n    double pos[3]; // Position vector\n    double vel[3]; // Velocity vector\n    double radius; // Radius -- added this new member here\n};\n\ndouble density(body planet); // Declaration of the function\n\nint main() \n{\n    body earth; \n  \n    earth.mass = 6.0e24; // Mass of earth [kg]\n    earth.radius = 6.3781e6; // Radius of earth [m]\n    \n    double rho = density(earth); // Declare and call density function to define rho\n    \n    cout &lt;&lt; \"Density of Earth = \" &lt;&lt; rho &lt;&lt; \" kgm^-3\" &lt;&lt; endl;\n    \n    return EXIT_SUCCESS;\n}\n\ndouble density(body planet) // Definition of the function\n{\n    double volume = (4.0/3.0)*M_PI*pow(planet.radius,3);\n    double rho = planet.mass/volume;\n    return rho; \n}\nHere the entire body structure, including all the arrays inside it, are deep-copied into a new local variable planet that is accessible only inside the density() function. We can remedy this potential inefficiency by using pass-by-reference discussed last week.\nThe philosophy of designing a structure to encapsulate logically related variables was essentially the first embryonic step (in C) towards fully object orientated programming (OOP) (in C++). A fully OOP approach would define object classes which group together in a logical way both data, e.g. as in body, and functions for manipulating that data, e.g. like density().",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Structures and Objects"
    ]
  },
  {
    "objectID": "structures_objects.html#a-first-look-at-objects-in-c",
    "href": "structures_objects.html#a-first-look-at-objects-in-c",
    "title": "Structures and Objects",
    "section": "A first look at Objects in C++",
    "text": "A first look at Objects in C++\nAs we have mentioned many times C++ is an OOP language built on C. For the most part we have really only used the the OOP power of C++ very tangentially in this course. For our final topic it is therefore fitting that we discuss briefly how we can build objects in C++. What we will see is that C++ upgrades structures from C into fully fledged classes.",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Structures and Objects"
    ]
  },
  {
    "objectID": "structures_objects.html#declaring-a-class",
    "href": "structures_objects.html#declaring-a-class",
    "title": "Structures and Objects",
    "section": "Declaring a class",
    "text": "Declaring a class\nStructures allow us to create sophisticated new abstract data types with many different members potentially of different primitive types or other structures. The purpose of a class is to embed functions that manipulate data with data itself creating a logical unit. This is best illustrated by an example and consistent with the flavour of this course it will be based on numbers. Let’s create a C++ class for rational numbers, so numbers which can be expressed as a fraction \\(a/b\\) of two integers. Here is what a basic class declaration would look like:\n/* --- Declaration of rational --- */\n\nclass rational {\n    public:\n        // Constructors\n        rational();\n        rational(int a, int b);\n        // Responsibilities \n        int GetNumerator() const;\n        int GetDenominator() const;\n    private:\n        int numerator; // The numerator\n        int denominator; // The denominator\n};\nIn contrast to a struct a class has public methods by which you can interact with the object and private data that cannot be accessed directly (this is so-called data encapsulation). For rational numbers the data is simply the numerator and denominator integers. The public methods include constructors, these are functions that initialise an instance of the class, and additional functions for getting the numerator and denominator (since we don’t have access to those variables directly).",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Structures and Objects"
    ]
  },
  {
    "objectID": "structures_objects.html#implementing-a-class",
    "href": "structures_objects.html#implementing-a-class",
    "title": "Structures and Objects",
    "section": "Implementing a class",
    "text": "Implementing a class\nHaving declared our class we now need to implement its methods. Here is what this might look like:\n/* --- Implementation of rational --- */\n\n// Default construction:\nrational::rational()\n{\n    numerator = 0; // Set rational number to 0/1 = 0\n    denominator = 1;\n}\n\n// Parameterised construction:\nrational::rational(int a, int b)\n{\n    numerator = a; // Set rational number to a/b\n    denominator = b;\n}\n\n// Access methods:\nint rational::GetNumerator() const\n{\n    return numerator; \n}\n\nint rational::GetDenominator() const\n{\n    return denominator;\n}\nNotice that we define the name of these functions as rational::&lt;function&gt;, where :: is the scope resolution operator. We have used this already numerous times for e.g. std::cout. Here it is saying that these functions are methods belonging to the class rational. The methods themselves are extremely trivial in this example.",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Structures and Objects"
    ]
  },
  {
    "objectID": "structures_objects.html#using-a-class",
    "href": "structures_objects.html#using-a-class",
    "title": "Structures and Objects",
    "section": "Using a class",
    "text": "Using a class\nAssuming we put the class declaration and the class implementation in a single source file rational.cpp, then a program using this class could be:\n#include &lt;iostream&gt; // Usual library header\n\n/* --- Declaration of rational --- */\n\nint main()\n{\n    rational A; // Declare a rational number\n    rational B(231,983); // Declare and initialise a rational number\n    std::cout &lt;&lt; \"A = \" &lt;&lt; A.GetNumerator() &lt;&lt; \"/\" &lt;&lt; A.GetDenominator() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"B = \" &lt;&lt; B.GetNumerator() &lt;&lt; \"/\" &lt;&lt; B.GetDenominator() &lt;&lt; std::endl;\n    \n    return EXIT_SUCCESS;\n}\n\n/* --- Implementation rational --- */\nThe output from this program just confirms everything works as expected:\nA = 1/1\nB = 231/983\nWhile the rational class illustrates objects it could clearly be improved with more functionality. Let’s modify the class so it has some intuitive properties expected for numbers in a programming language. Consider the following declaration:\n/* --- Declaration of rational --- */\n\nclass rational {\n    public:\n        // Constructors\n        rational();\n        rational(int a, int b);\n        // Responsibilities \n        void print() const;\n        rational operator+(const rational& other_rational) const;\n    private:\n        int numerator; // The numerator\n        int denominator; // The denominator\n};\nand associated implementation:\n/* --- Implementation of rational --- */\n\n// Default construction:\nrational::rational()\n{\n    numerator = 0; // Set rational number to 0/1 = 0\n    denominator = 1;\n}\n\n// Parameterised construction:\nrational::rational(int a, int b)\n{\n    numerator = a; // Set rational number to a/b\n    denominator = b;\n}\n\n// Access methods:\nvoid rational::print() const\n{\n    std::cout &lt;&lt; numerator &lt;&lt; \"/\" &lt;&lt; denominator &lt;&lt; std::endl; // Print out number\n}\n\nrational rational::operator+(const rational& other_rational) const\n{\n    // Compute the addition of two rational numbers:\n    int a = numerator*other_rational.denominator + other_rational.numerator*denominator;\n    int b = denominator*other_rational.denominator;\n    rational sum(a,b); // Assign a new rational number\n    return sum; // Return this rational number\n}\nHere is a program demonstrating how this new version works:\n#include &lt;iostream&gt; // Usual library header\n\n/* --- Declaration of rational --- */\n\nint main()\n{\n    rational A(13,727); // Declare and initialise a rational number\n    rational B(231,983); // Declare and initialise a rational number\n    // Display the numbers:\n    A.print();\n    B.print(); \n    // Declare and initialise a rational number by adding the first two together:\n    rational C = A + B; // Can use + operation\n    C.print();\n    \n    return EXIT_SUCCESS;\n}\n\n/* --- Implementation rational --- */\nWhat is interest here is that we have overloaded the addition operator + for this class and thereby defined what A + B would be for two instances of rational. This is exactly the behaviour we would want from a number. Running this program confirms that \\(13/727 \\approx 0.0179\\) added to \\(231/983 \\approx 0.235\\) gives \\(180716/714641 \\approx 0.2529\\). We can overload many other operators such as -, / and even ++ so they are defined for this new data type. Hopefully the power of OOP design approach is now becoming apparent and exploring it in much more detail will be a major task for next year. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Structures and Objects"
    ]
  },
  {
    "objectID": "structures_objects.html#footnotes",
    "href": "structures_objects.html#footnotes",
    "title": "Structures and Objects",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou would need to remember that sun[4] is in fact the \\(y\\)-component of its velocity!↩︎",
    "crumbs": [
      "<B>Week 11 |</B> <I>Structures and Objects</I>",
      "Structures and Objects"
    ]
  },
  {
    "objectID": "pointers.html",
    "href": "pointers.html",
    "title": "Optional - Pointers",
    "section": "",
    "text": "These optional notes provide you with a concise introduction to pointers in C/C++. These notes are provided for two reasons. First, for completeness since you may come across the term pointer so it serves to demystify them. Second, pointers are an important low-level programming concept which underpins the implementation of lots of other high-level functionality. In essence we use them without really knowing.",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "*Optional* - Pointers"
    ]
  },
  {
    "objectID": "pointers.html#what-are-pointers",
    "href": "pointers.html#what-are-pointers",
    "title": "Optional - Pointers",
    "section": "What are Pointers?",
    "text": "What are Pointers?\nRecall that in most programming languages a variable is some information stored in a memory space used by a program. typically called its stack. So far, we considered the information itself, namely the value of the variable. We can also consider where the information is stored, namely the address of the variable. Viewing the random access memory (RAM) as a set of boxes then the value is the contents of the box, while the address is the location of the box. In C/C++ there are special variables called pointers whose purpose is to store addresses of other variables. When first encountered the concept of pointers can be confusing, however they are extremely important and will be needed for any serious computation.\nLike variables, pointers must be declared. They point to variables of a specific type, for example int or float. Declarations of pointers start involve an asterisk attached either to the from of the pointers name as &lt;type&gt; *&lt;p_name&gt;, or to the end of the type as &lt;type&gt;* &lt;p_name&gt;, for example:\nint *pointer1; // A style preferred by C programmers emphasising expressions\nint* pointer2; // A style preferred by C++ programmers emphasising types\nBoth are completely legal forms1. It is a matter of taste which you use, but be careful using the C++ style when declaring multiple pointers:\nint *pointer1, *pointer2; // Declares two pointers to int\nint* pointer1, pointer2; // Declares pointer1 as a pointer, but pointer2 is int!\nIf you use the C++ style then declare pointers one at a time.\nThere are three basic usages of pointers:\n\nReferencing - We can access the memory address of any variable using the & symbol in front of the variable name. This is called referencing the variable and we can read & as being the “get the address of\" operation. Hence myPointer = &myVariable; assigns the address of the variable to a pointer.\nDe-referencing - To access the value stored at an address in a pointer we use the symbol in front of the name of the pointer. This is called de-referencing the pointer and we can read in this context as being the “get the value at the address\" operation2. Hence newVariable = *myPointer; gets the value stored at that address stored in the pointer and assigns it to the new variable.\nAssignment - De-referencing not only gets the value at an address it can also change it. For example, suppose we has declared int* myPointer; then myPointer = 12; stores the value 12 at the address pointed to by myPointer. We can also use myPointer = (*myPointer) + 2; which increments the value at the address by 2. In fact, you can use (*myPointer) in expressions identically to how you would use a variable of the same type3.\n\nThese usages are illustrated in Figure 1 and also clarified in the following simple example:\nint main() \n{\n    int firstVar, secondVar;\n    int* ptr; // Declare a pointer to int\n    firstVar = 5; \n    secondVar = 2;\n    \n    ptr = &firstVar; // Store the address of the first variable in ptr\n    (*ptr)++; // Increment the value that ptr points to\n    secondVar = *ptr; // Set the second variable to the value pointed to by ptr\n    // Both firstVar and secondVar now have the value 6 \n    \n    return 0;\n}\nEven if you have not encountered pointers before you have almost certainly used them without knowing, e.g. they are implicit in Python. There are (at least) four primary uses of pointers:\n\nPassing a variable by reference rather than value\nThis will be discussed more next week when we will look at functions. Pointers provide a means for a function to modify their inputs.\nPassing large amounts of data\nIf a large quantity of data (like an array) needs to be passed to a function it is much more efficient to send the address of the data than copy across the entire set of data itself.\nHandling more complex data\nPointers enable sophisticated data structures to be created liked linked-lists and arrays of structures.\nDynamical memory allocation\nWe have seen that arrays in C/C++ have a fixed size at compile-time, but we can have arrays with a size that is determined in run-time by using pointers and dynamical memory allocation (see shortly).\n\nWe will consider the first three in more detail next week. Here we will focus on the last point by first expanding on the relation between pointers and arrays.",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "*Optional* - Pointers"
    ]
  },
  {
    "objectID": "pointers.html#pointer-arithmetic",
    "href": "pointers.html#pointer-arithmetic",
    "title": "Optional - Pointers",
    "section": "Pointer arithmetic",
    "text": "Pointer arithmetic\nSuppose that myPointer stores the address of a variable myVariable. We know that myPointer gives the value of the variable, and that (*myPointer)+1; adds 1 to the value of the variable. So what is myPointer+1; where no de-referencing is used? Answer: it increments the pointer to the adjacent block of memory that could store a variable of its type. Specifically, memory is address in bytes so myPointer+1; increments the address stored by sizeof(&lt;type&gt;) bytes. This kind of arithmetic works with any integer value so myPointer-1; decrements to the block to the one before, while declaring an integer variable int i = 10; and using myPointer+i; increments 10 blocks ahead.\nNote, however, that we should never use pointer arithmetic like this for a pointer assign to the address of single variable. Why? Because, we have no guarantee the next block of memory pointed to by myPointer+1; is actually another valid variable of the same type in our program. For example, we could be addressing an int and increment to the next 4 bytes in the memory which might be storing a double. In this case we will wrongly interpret half of the double’s 8 bytes as an int. In other words we get junk, as shown in Figure 2. The usefulness of pointer arithmetic only becomes clear when we know a sequence of contiguous variables of one type are stored in the memory, for example in an array.\n\n\n\n\n\n\nFigure 2: An example of a programs memory with int, short and double variables stored, along with an int* pointer ptr pointing at the int variable. Pointer arithmetic on ptr indexes across the memory in 4 byte chunks corresponding to its type. In this case ptr + 1 points at a block of memory spanning the short and double variable, so will return junk.",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "*Optional* - Pointers"
    ]
  },
  {
    "objectID": "pointers.html#arrays-and-pointers",
    "href": "pointers.html#arrays-and-pointers",
    "title": "Optional - Pointers",
    "section": "Arrays and pointers",
    "text": "Arrays and pointers\nWhen you declare an array, such as float arr[5];, the array name arr is actually a pointer to the memory location for the first element of the array, so formally for this 1D array arr and &arr[0] are the equivalent. This means we can access elements of the array using either the index notation, e.g. arr[3], or via pointer arithmetic and de-referencing, e.g. (arr + 3). This works both ways. So given a pointer ptr we can also access block beyond it by using index notation, so ptr[2] is equivalent to (ptr + 2). The following example illustrates these points:\n#include &lt;iostream&gt;\n\nint main() \n{\n  static const int num = 3; // Number of values\n  float vals[] = {3.14,2.71,6.28};\n  float *ptr;\n\n  ptr = vals; // Point to start of array, equivalent to ptr = &vals[0];\n\n  for(unsigned int i=0;i&lt;num;i++)\n  {\n    std::cout &lt;&lt; *(vals + i) &lt;&lt; \" squared is \"; // Pointer arithmetic same as vals[i]\n    *(ptr+i) = *(ptr+i) * *(ptr+i); // Square an update the value in vals[i].\n    std::cout &lt;&lt; ptr[i] &lt;&lt; \"\\n\"; // Access what ptr points to using index notation\n  }\n}\nLine 14 here provides an example of pointer de-referencing and multiplication all in the same expression4. What happens if you set num = 20? Your code will compile because C/C++ does not check whether your code violates the bounds of an array. One of two things will happen when you run it. Your code will run and exit normally, but display lots of junk values beyond the 3 expected ones. Or your code will abort abnormally and may display a dreaded segmentation fault error.\nNaturally the next question is how are multi-dimensional arrays related to pointers. Take a 2D example float A[3][4];. Unlike the 1D case the array itself A is not a pointer and we do not have an equivalence between A and the address of its first element &A[0][0] here. Rather A is a pointer to the first of 3 1D arrays of 4 floats representing the rows. Yet we have seen already that 1D arrays are actually pointers, so A is said to be a pointer to a pointer. This multiple level of indirection (which grows for higher dimensional arrays) can be quite mind-boggling and we will avoid discussing it further.\nInstead, we will exploit the fact that the dimensionality of arrays is really an illusion. In reality, irrespective of their dimensions, all arrays are really just a linear contiguous blocks of memory. So given an n \\(\\times\\) m array A we assign a pointer ptr = &A[0][0] to its first element, and then access its elements as (ptr + k) or ptr[k], with k = 0,1,2,\\(\\dots\\), n*m. We can replicate the row i and column j indexing used by the array notation A[i][j] by constructing the counter as k = j + m*i and using ptr[k]. This is illustrated in the following listing:\n#include &lt;iostream&gt;\n\nint main() \n{\n  static const int n = 3; // Number of rows\n  static const int m = 4; // Number of columns\n  float A[n][m] = {{3.14,2.71,6.28,65.43},\n                   {4.78,9.12,42.32,0.98},\n                   {8.74,3.21,90.81,24.92}};\n  float *ptr;\n\n  ptr = &A[0][0]; // Point to start of array\n\n  // Access elements as 1D through pointer:\n  for(unsigned int k=0;k&lt;n*m;k++) std::cout &lt;&lt; ptr[k] &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"\\n\";\n\n  // Access elements as 2D through pointer:\n  for(unsigned int i=0;i&lt;n;i++)\n  {\n    for(unsigned int j=0;j&lt;m;j++)\n    {\n       unsigned int k = j + m*i; // Row-major indexing\n       std::cout &lt;&lt; ptr[k] &lt;&lt; \" \"; // Here ptr[k] is equivalent to A[i][j]\n    }\n    std::cout &lt;&lt; \"\\n\"; // Display as a matrix\n  }\n  return 0;\n}\nWe can generalise this approach to higher dimensional arrays straightforwardly.",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "*Optional* - Pointers"
    ]
  },
  {
    "objectID": "pointers.html#dynamic-memory-allocation",
    "href": "pointers.html#dynamic-memory-allocation",
    "title": "Optional - Pointers",
    "section": "Dynamic memory allocation",
    "text": "Dynamic memory allocation\nAs we have discussed already an array in C/C++ has a fixed size defined at compile-time in your source code. This can often be a severe limitation since there are many situations when you do not know how large your arrays will be in advance, or want to allow you code to be able handle any size requested by the user. The modern C++ solution to this is to use the vector class as discussed in the main notes. This approach is strongly recommended.\nAnother more primitive way around this issue is to perform dynamic memory allocation which you may see in older code. Specifically, we request from the operating system using the malloc function that it assign us during run-time a block of memory sufficient to store our array. Here is a simple example:\n#include &lt;iostream&gt;\n\nint main() \n{\n  int *arr; // Pointer which will point at the memory we will be allocated\n  int num; // Size of our array to be specified at run-time\n  \n  std::cout &lt;&lt; \"How many integers? \";\n  std::cin &gt;&gt; num; // Request a size\n  \n  size_t arraysize = num*sizeof(int); // Number of bytes required\n  \n  arr = (int*) malloc(arraysize); // Request memory and cast output as int pointer\n\n  // Display the contents of the memory allocated:\n  for(unsigned int i=0;i&lt;num;i++) std::cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; \"\\n\";\n  \n  free(arr); // Release the memory allocated\n  return 0;\n}\nDepending on your operating system this may display 0’s5 or junk left over since we did not initialise any of the values in arr. Notice it is best practice to use the size_t type of unsigned integer to store sizes of memory since it can handle any theoretical size requested on a given machine. Once memory has been allocated to arr behaves in all respects just like an explicitly defined 1D array of int’s of size num.\nOn line 26 we release the memory allocated using free(arr);. For this short program, which finishes right after, missing this line would do no harm. However, for more complex code if you do not free up memory after you are done with it you will consume more resources than is necessary potentially slowing its execution speed. Worse still if you reassigned arr via another malloc call to some new memory without freeing up the memory originally allocated you will produce what is called a memory leak. This is where code keeps consuming increasing amounts of memory and is a nasty bug.\nWe can readily generalise dynamic memory allocation to other variable types and to multi-dimensional arrays as illustrated here:\n#include &lt;iostream&gt;\n\nint main() \n{\n  double *arr;\n  int n, m; // Size of our 2D double array to be specified at run-time\n  \n  std::cout &lt;&lt; \"n = \";\n  std::cin &gt;&gt; n; // Number of rows\n  std::cout &lt;&lt; \"m = \";\n  std::cin &gt;&gt; m; // Number of columns\n  \n  size_t arraysize = n*m*sizeof(double); // Number of bytes required\n  arr = (double*) malloc(arraysize); // Request memory and cast output as double pointer\n\n  // Display the contents of the memory allocated:\n  for(unsigned int i=0;i&lt;n;i++)\n  {\n    for(unsigned int j=0;j&lt;m;j++)\n    {\n      unsigned int k = j + m*i; // Row-major indexing\n      std::cout &lt;&lt; arr[k] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"\\n\"; // Display as a matrix\n  }\n  free(arr); // Release the memory allocated\n  return 0;\n}\nIn scientific computations double arrays indexed over 2D or 3D are very common place. \\(\\Box\\)",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "*Optional* - Pointers"
    ]
  },
  {
    "objectID": "pointers.html#footnotes",
    "href": "pointers.html#footnotes",
    "title": "Optional - Pointers",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote that &lt;type&gt; * &lt;p_name&gt; or &lt;type&gt;*&lt;p_name&gt; are also legal forms, but should be avoided due to their visual similarity to multiplication.↩︎\nBeware: the symbol is the same as that used for multiplication. However, multiplication always involves two numbers while pointer de-referencing involves one pointer, so no confusion should ever arise.↩︎\nNote: brackets are important only to avoid ambiguity with pointer arithmetic: see later.↩︎\nArguably ptr[i] = ptr[i]*ptr[i]; would have looked much less confusing!↩︎\nIf new memory is allocated by the operating system it is often zeroed for security reasons.↩︎",
    "crumbs": [
      "<B>Week 9 |</B> <I>Arrays and Vectors</I>",
      "*Optional* - Pointers"
    ]
  }
]